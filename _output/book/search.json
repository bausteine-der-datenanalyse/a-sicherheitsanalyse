[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "",
    "text": "Einleitung",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nZum erfolgreichen Bearbeiten dieses Anwendungsbausteins benötigen Sie die Inhalte des Methodenbausteins Grundlagen der Statistik und des Werkzeugbausteins Datenanalyse in R. Außerdem sollten Grundbegriffe der verkehrlichen Sicherheitsanalyse wie die Unfallrate, Unfalldichte, Unfallkosten und Sicherheitspotentiale bekannt sein.",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nZiel dieses Bausteins ist es, typische Inhalte von sicherheitsrelevanten Fragestellungen von Verkehrsnetzen in grafischer Form mithilfe der Programmiersprache R darzustellen. Dabei lernen Sie, wo deutschsprachige Unfalldaten gefunden werden können, wie Unfalldaten eingelesen, aufbereitet und analysiert werden und welche verschiedenen Darstellungsformen sich für bestimmte Datentypen eignen.",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#verwendete-datensätze",
    "href": "index.html#verwendete-datensätze",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Verwendete Datensätze",
    "text": "Verwendete Datensätze\nDaten des Straßennetzes des Bundesinformationssystem Straße (BISStra) der Bundesanstalt für Straßen- und Verkehrswesen (BASt)\nUnfalldaten des Unfallatlas des Statistischen Bundesamts\nVerkehrsmengen der Dauerzählstellen der BASt",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#literatur",
    "href": "index.html#literatur",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Literatur",
    "text": "Literatur\nForschungsgesellschaft für Straßen- und Verkehrswesen (FGSV) (2003): Empfehlungen für die Sicherheitsanalyse von Straßennetzen (ESN)",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "aufgabenstellung.html",
    "href": "aufgabenstellung.html",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "",
    "text": "1.1 Datenquellen\nDie statistischen Ämter des Bundes und der Länder erheben und veröffentlichen mit der Straßenverkehrsunfallstatistik die Verkehrsunfälle mit Personenschaden oder Sachschaden in Deutschland. Im Unfallatlas werden Unfälle mit Personenschaden geführt. Für die Sicherheitsanalyse von Verkehrsnetzen können diese Daten verwendet und analysiert werden.\nVerwenden Sie für das Straßennetz die Daten des Bundesinformationssystems Straße (BISStra) der Bundesanstalt für Straßen- und Verkehrswesen (BASt), Stichwortsuche “Bundesfernstraßennetz”.\nDie durchschnittliche Verkehrsstärke (DTV) auf Autobahnen kann ebenfalls über die BASt unter dem Stichwort “Dauerzählstellen” bezogen werden.\nDie Formeln der Kenngrößen für die Sicherheitsbewertung werden den Empfehlungen für die Sicherheitsanalyse von Straßennetzen (ESN) (2003) der Forschungsgesellschaft für Straßen- und Verkehrswesen (FGSV) entnommen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabenstellung.html#datenquellen",
    "href": "aufgabenstellung.html#datenquellen",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "",
    "text": "Übungsaufgabe 1.1 (Anzahl der Verkehrsunfälle) Erstellen Sie eine tabellarische Übersicht der Unfallzahlen nach Unfallkategorie für eine ausgewählte Autobahn und für Gesamtdeutschland in einem frei wählbaren Jahr.\n\n\nÜbungsaufgabe 1.2 (Unfallkenngrößen auf Autobahnen) Stellen Sie die folgende Unfallkenngrößen für eine ausgewählte Autobahn in einem frei wählbaren Jahr grafisch dar:\n\ndie Unfallrate UR,\ndie Unfalldichte UD,\ndie Unfallkostenrate UKR,\ndie Unfallkostendichte UKD und\ndas Sicherheitspotential SIPO",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "musterloesung.html",
    "href": "musterloesung.html",
    "title": "2  Musterlösung Sicherheitsanalyse",
    "section": "",
    "text": "2.1 Übungsaufgabe 1.1 : Anzahl der Verkehrsunfälle\nVerwendete Pakete laden\nDaten einlesen und aufbereiten\nTabellarische Darstellung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Sicherheitsanalyse</span>"
    ]
  },
  {
    "objectID": "musterloesung.html#übungsaufgabe-1.1-anzahl-der-verkehrsunfälle",
    "href": "musterloesung.html#übungsaufgabe-1.1-anzahl-der-verkehrsunfälle",
    "title": "2  Musterlösung Sicherheitsanalyse",
    "section": "",
    "text": "```{r}\nd_unfaelle_2023 = read_csv2(\"daten/Unfallorte2023_LinRef.csv\") |&gt;\n  st_as_sf(coords = c(\"LINREFX\", \"LINREFY\"), crs = 25832) |&gt;\n  st_zm()\n```\n```{r}\nif (!file_exists(\"daten/BFStr_Netz_v2025q3.gpkg\")) {\n  curl_download(\"https://www.bast.de/SharedDocs/Daten-TB/Daten-BISStra.zip?__blob=publicationFile&v=5\", destfile = \"daten/Daten-BISStra.zip\", quiet = FALSE)\n  unzip(\"daten/Daten-BISStra.zip\", exdir = \"daten/\")\n}\n\nd_bfstn &lt;- read_sf(\"daten/BFStr_Netz_v2025q3.gpkg\") |&gt;\n  filter(Str_Klasse_kurz == \"A\" & Sk_Achse == \"Bestandsachse\") |&gt;\n  mutate(rownumber = row_number()) |&gt;\n  st_zm()\n```\n```{r}\nd_unfaelle_bab_2023 = d_unfaelle_2023 |&gt;\n    mutate(\n      abschnitt_id = st_nearest_feature(geometry, d_bfstn),\n      distanz = st_distance(geometry, d_bfstn[abschnitt_id, ], by_element = TRUE),\n      name = d_bfstn$Str_Kennung[abschnitt_id]\n    ) |&gt;\n  filter(as.double(distanz) &lt;= 20) |&gt;\n  select(UKATEGORIE, name, abschnitt_id)\n```\n\n```{r}\nd_zaehle_unfaelle &lt;- d_unfaelle_bab_2023 |&gt;\n  st_drop_geometry() |&gt;\n  group_by(UKATEGORIE) |&gt;\n  summarise(\n    A38 = sum(name == \"A38\"),\n    Autobahnen = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(UKATEGORIE = as.character(UKATEGORIE))\n\ntabelle_unfaelle &lt;- d_zaehle_unfaelle |&gt;\n  bind_rows(summarise(d_zaehle_unfaelle, UKATEGORIE = \"Summe\", across(c(A38, Autobahnen), sum))) |&gt;\n  rename(Unfallkategorie = UKATEGORIE) |&gt;\n  mutate(\n    Unfallkategorie = case_when(\n      Unfallkategorie == \"1\" ~ \"Unfall mit Getöteten\",\n      Unfallkategorie == \"2\" ~ \"Unfall mit Schwerverletzten\",\n      Unfallkategorie == \"3\" ~ \"Unfall mit Leichtverletzten\",\n      TRUE ~ Unfallkategorie\n    )\n  )\n\n\nkable(\n  tabelle_unfaelle,\n  caption = \"Anzahl der Verkehrsunfälle nach Unfallkategorie (A38 und alle deutschen Autobahnen) im Jahr 2023\"\n)\n```",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Sicherheitsanalyse</span>"
    ]
  },
  {
    "objectID": "musterloesung.html#übungsaufgabe-1.2-unfallkenngrößen-auf-autobahnen",
    "href": "musterloesung.html#übungsaufgabe-1.2-unfallkenngrößen-auf-autobahnen",
    "title": "2  Musterlösung Sicherheitsanalyse",
    "section": "2.2 Übungsaufgabe 1.2 : Unfallkenngrößen auf Autobahnen",
    "text": "2.2 Übungsaufgabe 1.2 : Unfallkenngrößen auf Autobahnen\n\n2.2.1 Die Unfallrate UR\nDauerzählstellendaten einlesen und aufbereiten\n```{r}\nd_dzs_2023 &lt;- read_csv2(\"daten/Jawe2023.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  st_as_sf(coords =  c(\"Koor_UTM32_E\", \"Koor_UTM32_N\"),  crs = 25832) |&gt;\n  st_zm() |&gt;\n  mutate(abschnitt_id = st_nearest_feature(geometry, d_bfstn))\n```\n```{r}\nd_dzs_2023 |&gt;\n  st_drop_geometry() |&gt;\n  group_by(abschnitt_id) |&gt;\n  filter(n() &gt; 1) |&gt;\n  select(abschnitt_id, DZ_Nr, DTV_Kfz_MobisSo_Q)\n```\n```{r}\nd_dzs_abschnitt_2023 &lt;- d_dzs_2023 |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    DTV_2023 = mean(DTV_Kfz_MobisSo_Q, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  select(abschnitt_id, DTV_2023)\n```\n```{r}\nd_unfaelle_abschnitt_2023 &lt;- d_unfaelle_bab_2023 |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    d_unfaelle_2023 = n(),\n    .groups = \"drop\"\n  )\n```\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn |&gt;\n  mutate(abschnitt_id = row_number()) |&gt;\n  mutate(laenge_km = as.numeric(Sk_Laenge_m)/1000) |&gt;\n  left_join(d_dzs_abschnitt_2023, by = \"abschnitt_id\") |&gt;\n  left_join(d_unfaelle_abschnitt_2023, by = \"abschnitt_id\") |&gt;\n  select(Str_Kennung, laenge_km, DTV_2023, d_unfaelle_2023, abschnitt_id)\n```\nUnfallraten berechnen\n```{r}\nt1 = 1\n```\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(unfallrate = d_unfaelle_2023 * 10^6 / (DTV_2023 * laenge_km * 365  * t1)) \n```\n```{r}\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n```\nGraphische Darstellung\n```{r}\nd_A38 &lt;- d_bfstn |&gt; filter(Str_Kennung == \"A38\")\nd_staedte &lt;- st_as_sf(\n  tibble::tribble(\n  ~stadt, ~lat, ~lon,\n  \"Leipzig\", 51.3402, 12.3601,\n  \"Nordhausen\", 51.5018, 10.7957,\n  \"Göttingen\", 51.5455, 9.9055,\n  ),\n  coords = c(\"lon\", \"lat\"),\n  crs = 4326\n) |&gt;\n  st_transform(25832)\n\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label = stadt), nudge_y = 5000) +\n  geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfallrate)), \n    size = 2.5, \n    mapping = aes(color = unfallrate)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallrate\\n(Unfälle pro\\n1 Mio. Kfz-km)\") +\n  labs(title = \"Unfallraten nach Abschnitten der A38 im Jahr 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n```\n\n\n2.2.2 Die Unfalldichte UD\nUnfalldichte berechnen\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(unfalldichte = d_unfaelle_2023 / (laenge_km * t1))                             \n```\n```{r}\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n```\nGraphische Darstellung\n```{r}\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfalldichte)), \n    size = 2.5, \n    mapping = aes(color = unfalldichte)\n    ) +\n  scale_color_viridis_b(direction = -1, limits = c(0, 10),  name = \"Unfalldichte\\n(Unfälle pro\\nkm und Jahr)\") +\n  labs(title = \"Unfalldichten nach Abschnitten der A38 im Jahr 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n```\n\n\n2.2.3 Die Unfallkostenrate UKR\nUnfalldaten einlesen und aufbereiten\n```{r}\nd_unfaelle_alle &lt;- bind_rows(\n  read.csv2(\"daten/Unfallorte2023_LinRef.csv\") |&gt; mutate(jahr = 2023),\n  read.csv2(\"daten/Unfallorte2022_LinRef.csv\") |&gt; mutate(jahr = 2022),\n  read.csv2(\"daten/Unfallorte2021_LinRef.csv\") |&gt; mutate(jahr = 2021),\n  ) |&gt;\n  st_as_sf(coords = c(\"LINREFX\", \"LINREFY\"), crs = 25832) |&gt;\n  st_zm()\n```\n```{r}\nd_unfaelle_bab_alle &lt;- d_unfaelle_alle |&gt;\n  mutate(\n    abschnitt_id = st_nearest_feature(geometry, d_bfstn),\n      distanz = st_distance(geometry, d_bfstn[abschnitt_id, ], by_element = TRUE),\n      name = d_bfstn$Str_Kennung[abschnitt_id]\n    ) |&gt;\n  filter(as.double(distanz) &lt;= 20) |&gt;\n  select(UKATEGORIE, name, abschnitt_id, jahr)\n```\n```{r}\nd_unfaelle_abschnitt_alle &lt;- d_unfaelle_bab_alle |&gt;\n  st_set_geometry(NULL) |&gt;\n    group_by(abschnitt_id, UKATEGORIE) |&gt;\n    summarise(\n      Unfaelle = n(),\n      .groups = \"drop\"\n  ) \n```\nUnfallschwere bestimmen\n```{r}\nd_unfaelle_sp_3j &lt;- d_unfaelle_abschnitt_alle |&gt;\n  filter(UKATEGORIE %in% c(1, 2)) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    unfaelle_sp_summe_3j = sum(Unfaelle, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nd_unfaelle_lv_3j &lt;- d_unfaelle_abschnitt_alle |&gt;\n  filter(UKATEGORIE == 3) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    unfaelle_lv_summe_3j = sum(Unfaelle, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n```\n```{r}\nd_unfaelle_gesamt &lt;- d_unfaelle_sp_3j |&gt;\n  full_join(d_unfaelle_lv_3j, by = \"abschnitt_id\") |&gt;\n  mutate(\n    unfaelle_sp_summe_3j = replace_na(unfaelle_sp_summe_3j, 0),\n    unfaelle_lv_summe_3j = replace_na(unfaelle_lv_summe_3j, 0)\n  )\n```\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(abschnitt_id = row_number()) |&gt;\n  left_join(d_unfaelle_gesamt, by = \"abschnitt_id\") |&gt;\n  select(Str_Kennung, laenge_km, DTV_2023, d_unfaelle_2023, abschnitt_id, laenge_km, unfallrate, unfalldichte, unfaelle_sp_summe_3j, unfaelle_lv_summe_3j)\n```\nDauerzählstellendaten einlesen und aufbereiten\n```{r}\nd_dzs_alle &lt;- bind_rows(\n  read_csv2(\"daten/Jawe2023.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt; mutate(jahr = 2023),\n  read_csv2(\"daten/Jawe2022.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt; mutate(jahr = 2022),\n  read_csv2(\"daten/Jawe2021.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt; mutate(jahr = 2021),\n  ) |&gt;\n  st_as_sf(coords =  c(\"Koor_UTM32_E\", \"Koor_UTM32_N\"),  crs = 25832) |&gt;\n  st_zm()\n```\n```{r}\nd_dzs_bab_alle &lt;- d_dzs_alle|&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  mutate(abschnitt_id = st_nearest_feature(geometry, d_bfstn))\n```\n```{r}\nd_dzs_abschnitt_alle &lt;- d_dzs_bab_alle |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(DTV = mean(DTV_Kfz_MobisSo_Q, na.rm = TRUE))\n```\n```{r}\nd_dzs_gesamt &lt;- d_dzs_abschnitt_alle |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    dtv_mittelwert_3j = round(mean(DTV, na.rm = TRUE)),\n    .groups = \"drop\"\n  )\n```\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  left_join(d_dzs_gesamt, by = \"abschnitt_id\")\n```\nUnfallkostensätze definieren\n```{r}\nWU_SP_bab = 325000\nWU_LV_bab = 31000\nt2 = 3\n```\nUnfallkostenraten berechnen\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(\n    unfallkosten = unfaelle_sp_summe_3j * WU_SP_bab + unfaelle_lv_summe_3j * WU_LV_bab ,\n    unfallkostenrate = (1000*unfallkosten)/(365*dtv_mittelwert_3j*laenge_km*t2)\n  )\n```\n```{r}\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n```\nGraphische Darstellung\n```{r}\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfallkostenrate)), \n    size = 2.5, \n    mapping = aes(color = unfallkostenrate)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallkostenrate\\n(Euro pro\\n1000 Kfz und km und Jahr)\") +\n  labs(title = \"Unfallkostenraten nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n```\n\n\n2.2.4 Unfallkostendichte UKD\nUnfallkostendichte berechnen\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(unfallkostendichte = unfallkosten/(1000*laenge_km*t2))\n```\n```{r}\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n```\nGraphische Darstellung\n```{r}\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfallkostendichte)), \n    size = 2.5, \n    mapping = aes(color = unfallkostendichte)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallkostendichte\\n(1000 Euro pro\\nkm und Jahr)\") +\n  labs(title = \"Unfallkostendichten nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n```\n\n\n2.2.5 Sicherheitspotenzial SIPO\nGrundunfallkostenrate bestimmen\n```{r}\ngUKR_bab = 11\n```\nSicherheitspotenzial berechnen\n```{r}\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(\n    gUKD = (gUKR_bab * dtv_mittelwert_3j * 365)/10^6,\n    sicherheitspotenzial = unfallkostendichte - gUKD\n)\n```\n```{r}\nd_A38_gesamt  &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n```\nGraphische Darstellung\n```{r}\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(sicherheitspotenzial)), \n    size = 2.5, \n    mapping = aes(color = sicherheitspotenzial)\n    ) +\n  scale_color_viridis_b(direction = -1, breaks = c(0, 50, 100), name = \"Sicherheitspotenzial\\n(1000 Euro pro\\nkm und Jahr)\") +\n  labs(title = \"Sicherheitspotenziale nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n```",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Sicherheitsanalyse</span>"
    ]
  },
  {
    "objectID": "musterloesung-erlaeutert.html",
    "href": "musterloesung-erlaeutert.html",
    "title": "3  Musterlösung mit Erläuterungen",
    "section": "",
    "text": "3.1 Übungsaufgabe 1.1 : Anzahl der Verkehrsunfälle\nAls frei wählbare Jahr wird 2023 gewählt und als frei wählbare Autobahn die A38.\nAls erstes werden die Daten vom Unfallatlas heruntergeladen und in R geladen. Danach wird der Datensatz mit “st_as_sf” in ein räumliches Punktobjekt umgewandelt. Die Koordinaten stammen aus den Spalten “LINREFX” und “LINREFY”. Mit CRS (Coordinate Reference System) wird das Koordinatenreferenzsystem EPSG:25832 definiert. Falls sich in den geometrischen Daten noch Informationen zur Höhe (z-Dimension) oder Messwerte oder Attribute (m-Dimension) enthalten sind, werden diese nun entfernt, damit wir gleich sauber mit ihnen weiterrechnen können.\nd_unfaelle_2023 = read_csv2(\"daten/Unfallorte2023_LinRef.csv\") |&gt;\n  st_as_sf(coords = c(\"LINREFX\", \"LINREFY\"), crs = 25832) |&gt;\n  st_zm()\nAls nächstes wird das Straßennetz der Bundesfernstraßen als Datensatz ins Projekt geladen. Diese Daten bekommen wir von der Bundesanstalt für Straßen- und Verkehrswesen (BASt). Das Bundesfernstraßennetz beinhaltet Daten zu Bundesautobahnen und Bundesstraßen. Aufgrund der Größe des Datensatzes kann dieser nicht auf Github zur Verfügung gestellt werden, daher fügen wir eine Funktion ein, die prüft, ob der Datensatz bereits im “daten”-Ordner liegt und falls nein, er direkt von der Webseite der BASt heruntergeladen, entpackt und an der richtigen Stelle gespeichert wird. Da für uns nur die Autobahnen relevant sind, filtern wir nur diese heraus. Wir wählen als Achse die Bestandsachse, da dies die mittlere Achse der Straße ist und wir keine Unterscheidung der Fahrtrichtung vornehmen müssen. Wir ergänzen eine Spalte (“mutate”) mit der Zeilennummer (brauchen wir gleich für die Unfälle). Auch hier entfernen wir potentielle Daten der z- oder m-Dimension.\nif (!file_exists(\"daten/BFStr_Netz_v2025q3.gpkg\")) {\n  curl_download(\"https://www.bast.de/SharedDocs/Daten-TB/Daten-BISStra.zip?__blob=publicationFile&v=5\", destfile = \"daten/Daten-BISStra.zip\", quiet = FALSE)\n  unzip(\"daten/Daten-BISStra.zip\", exdir = \"daten/\")\n}\n\nd_bfstn &lt;- read_sf(\"daten/BFStr_Netz_v2025q3.gpkg\") |&gt;\n  filter(Str_Klasse_kurz == \"A\" & Sk_Achse == \"Bestandsachse\") |&gt;\n  mutate(rownumber = row_number()) |&gt;\n  st_zm()\nDen Unfalldaten soll nun aufgrund ihrer Lage in Deutschland der nächstgelegene Autobahnabschnitt und die Entfernung zu diesem hinzugefügt werden. “st_nearest_feature” gibt dabei die Zeilennummer des nächstgelegenen Autobahnabschnitts im Datensatz “d_bfstn” wieder. “st_distance” berechnet die Entfernung vom Unfallpunkt zum nächstgelegenen Autobahnabschnitt, dies kann unter Umständen länger dauern. Außerdem suchen wir mit “d_bfstn$Str_Kennung[abschnitt_id]” aus dem Datensatz “d_bfstn” und der Spalte “Str_Kennung” genau den Eintrag, dessen Zeile durch “abschnitt_id” angegeben wird. Damit bekommen wir statt einer Nummer eines Autobahnabschnittes den Namen der Autobahn (z.B. A1). Zudem wollen wir nur Unfälle, die auf Autobahnen passiert sind, berücksichtigen. Dafür filtern wir nach Unfällen, die in einem 20 m Umkreis zur Bestandsachse der Autobahnen sind. Die 20 m wählen wir, um fast alle Unfälle auf den Fahrbahnen, auch bei 6- oder 8-spurigen Autobahnen, einzuschließen und fast alle Unfälle daneben auszuschließen. Es gibt uns aber keine Garantie, dass alle Unfälle, die wir nun filtern, tatsächlich auf Autobahnen liegen. Den Unterschied des Filters sehen wir im Environment: Der Unfalldatensatz aus 2023 beinhaltet 269.048 Unfälle insgesamt, der Unfalldatensatz für Autobahnen nur noch 22.114. Für mehr Übersichtlichkeit vereinfachen wir unseren Datensatz und lassen uns mit “select” nur bestimmte Spalten anzeigen.\nd_unfaelle_bab_2023 = d_unfaelle_2023 |&gt;\n    mutate(\n      abschnitt_id = st_nearest_feature(geometry, d_bfstn),\n      distanz = st_distance(geometry, d_bfstn[abschnitt_id, ], by_element = TRUE),\n      name = d_bfstn$Str_Kennung[abschnitt_id]\n    ) |&gt;\n  filter(as.double(distanz) &lt;= 20) |&gt;\n  select(UKATEGORIE, name, abschnitt_id)\ntodo: Nun folgt die tabellarische Darstellung. Mit “st_drop_geometry()” entfernen wir die Geometriespalte, da für die Auswertung in Tabellenform nur die Attributdaten benötigt werden. Anschließend gruppieren wir die Unfalldaten nach ihrer Kategorie (1, 2 oder 3) und berechnen mit “summarise” die Anzahl der Unfälle je Unfallkategorie, einmal für die Autobahn 38 und einmal für alle Autobahnen. Um eine weitere Zeile mit den Summen hinzufügen zu können, muss die Spalte zur Unfallkategorie in einen Zeichenvektor umgewandelt werden (“mutate(UKATEGORIE = as.character(UKATEGORIE))”). Die neue Zeile hängen wir mit “bind_rows()” an. Diese letzte Zeile der Spalte UKATEGORIE („Summe“) enthält nun die Gesamtanzahl aller Unfälle über alle Kategorien hinweg und dient als übersichtliche Gesamtsumme in der Ergebnistabelle. Nun benennen wir noch die Zeilennamen um. Mit “kable()” stellen wir die Tabelle dar und können ihr noch eine Überschrift hinzufügen.\nd_zaehle_unfaelle &lt;- d_unfaelle_bab_2023 |&gt;\n  st_drop_geometry() |&gt;\n  group_by(UKATEGORIE) |&gt;\n  summarise(\n    A38 = sum(name == \"A38\"),\n    Autobahnen = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(UKATEGORIE = as.character(UKATEGORIE))\n\ntabelle_unfaelle &lt;- d_zaehle_unfaelle |&gt;\n  bind_rows(summarise(d_zaehle_unfaelle, UKATEGORIE = \"Summe\", across(c(A38, Autobahnen), sum))) |&gt;\n  rename(Unfallkategorie = UKATEGORIE) |&gt;\n  mutate(\n    Unfallkategorie = case_when(\n      Unfallkategorie == \"1\" ~ \"Unfall mit Getöteten\",\n      Unfallkategorie == \"2\" ~ \"Unfall mit Schwerverletzten\",\n      Unfallkategorie == \"3\" ~ \"Unfall mit Leichtverletzten\",\n      TRUE ~ Unfallkategorie\n    )\n  )\n\n\nkable(\n  tabelle_unfaelle,\n  caption = \"Anzahl der Verkehrsunfälle nach Unfallkategorie (A38 und alle deutschen Autobahnen) im Jahr 2023\"\n)\n\n\nAnzahl der Verkehrsunfälle nach Unfallkategorie (A38 und alle deutschen Autobahnen) im Jahr 2023\n\n\nUnfallkategorie\nA38\nAutobahnen\n\n\n\n\nUnfall mit Getöteten\n8\n282\n\n\nUnfall mit Schwerverletzten\n43\n3739\n\n\nUnfall mit Leichtverletzten\n132\n18093\n\n\nSumme\n183\n22114",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Musterlösung mit Erläuterungen</span>"
    ]
  },
  {
    "objectID": "musterloesung-erlaeutert.html#übungsaufgabe-1.2-unfallkenngrößen-auf-autobahnen",
    "href": "musterloesung-erlaeutert.html#übungsaufgabe-1.2-unfallkenngrößen-auf-autobahnen",
    "title": "3  Musterlösung mit Erläuterungen",
    "section": "3.2 Übungsaufgabe 1.2 : Unfallkenngrößen auf Autobahnen",
    "text": "3.2 Übungsaufgabe 1.2 : Unfallkenngrößen auf Autobahnen\n\n3.2.1 Die Unfallrate UR\n“Die Unfallrate ist ein Maß für das (fahrleistungsbezogene) Risiko des Verkehrsteilnehmers, in einen Unfall verwickelt zu werden oder dabei zu verunglücken.” (FGSV 2003, 5) Die Formel lautet\n\\[\nUR = \\frac{U \\cdot 10^6}{DTV \\cdot L \\cdot 365 \\cdot t}\n\\] mit den Kenngrößen\n\nU: Anzahl der Unfälle\nDTV : durchschnittliche tägliche Verkehrsstärke in Kraftfahrzeugen pro 24 Stunden [Kfz/24h oder Kfz/d]\nL : untersuchte Streckenlänge [km]\nt : untersuchter Zeitraum [a].\n\nDie DTV kann den Dauerzählstellen der BASt entnommen werden. Die Streckenlänge ist im Datensatz des Bundesfernstraßennetzes bereits enthalten.\nAls erstes laden wir die Daten der Dauerzählstellen in unser Projekt. Mit dem Argument “locale(encoding =”iso-8859-1”)” stellen wir sicher, dass Umlaute und Sonderzeichen, die in deutschsprachigen Datensätzen häufig vorkommen, korrekt eingelesen werden. Da wir die Dauerzählstellen später mit dem Bundesfernstraßennetz verknüpfen möchten, berücksichtigen wir wie bei den anderen Datensätzen ausschließlich Autobahnen. Dazu filtern wir nach der Straßenklasse “Str_Kl ==”A”“. Anschließend entfernen wir mit”drop_na(DTV_Kfz_MobisSo_Q)” alle Beobachtungen, für die keine Verkehrsstärkewerte vorliegen, sodass nur vollständige und auswertbare Zählstellen verbleiben. Im nächsten Schritt wird der Datensatz in ein sf-Objekt umgewandelt. Aus den Koordinatenspalten “Koor_UTM32_E” und “Koor_UTM32_N” werden Punktgeometrien mit dem gleichen Koordinatensystem wie bei den anderen Datensätzen erzeugt. Dadurch sind spätere räumliche Operationen kompatibel. Wie auch bei den anderen räumlichen Datensätzen entfernen wir anschließend mögliche z- und m-Dimensionen aus den Geometrien. Im nächsten Schritt werden die Dauerzählstellen wie bei den Unfällen den nächstgelegenen Autobahnabschnitten des Bundesfernstraßennetzes zugeordnet. Mit “st_nearest_feature()” wird für jede Zählstelle der Index des nächstgelegenen Abschnitts ermittelt und als “abschnitt_id” gespeichert. Im Gegensatz zu den Unfalldaten müssen wir keine Entfernung zur Autobahn ermitteln, weil wir wissen, dass die Zählstellen tatsächlich an Autobahnen sind.\n\nd_dzs_2023 &lt;- read_csv2(\"daten/Jawe2023.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  st_as_sf(coords =  c(\"Koor_UTM32_E\", \"Koor_UTM32_N\"),  crs = 25832) |&gt;\n  st_zm() |&gt;\n  mutate(abschnitt_id = st_nearest_feature(geometry, d_bfstn))\n\nBevor wir mit den Daten der Dauerzählstellen weiterrechnen, prüfen wir, ob jedem Autobahnabschnitt maximal eine Dauerzählstelle zugeordnet ist. In unserem Verständnis ist ein Autobahnabschnitt u.a. dadurch klassifiziert, dass in diesem keine Auffahrt oder Abfahrt vorhanden ist, daher würden zwei Zählstellen hier nur redundante DTV-Werte liefern. Bevor wir mit dieser Annahme weiterrechnen, kontrollieren wir sie.\n\nd_dzs_2023 |&gt;\n  st_drop_geometry() |&gt;\n  group_by(abschnitt_id) |&gt;\n  filter(n() &gt; 1) |&gt;\n  select(abschnitt_id, DZ_Nr, DTV_Kfz_MobisSo_Q)\n\n# A tibble: 2 × 3\n# Groups:   abschnitt_id [1]\n  abschnitt_id DZ_Nr DTV_Kfz_MobisSo_Q\n         &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;\n1        14490 6730              28566\n2        14490 6831              45945\n\n\nWir sehen, dass unsere Annahme falsch ist und es tatsächlich einen Abschnitt mit zwei Zählstellen gibt und beide auch tatsächlich unterschiedliches Verkehrsaufkommen gibt. Zwischen den Zählstellen scheint es also auch die Möglichkeit zu geben, auf die Autobahn auf- oder von ihr abzufahren. Daher fassen wir die Verkehrsstärken nun auf Abschnittsebene zusammen. Hierzu wird die Geometrie entfernt und wir berechnen den mittlere DTV-Wert (“mean”) von beiden Zählstellen je Abschnitt. Und auch bei diesem Datensatz reduzieren wir die Anzahl der Spalten für mehr Übersichtlichkeit.\n\nd_dzs_abschnitt_2023 &lt;- d_dzs_2023 |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    DTV_2023 = mean(DTV_Kfz_MobisSo_Q, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  select(abschnitt_id, DTV_2023)\n\n\n3.2.1.1 Verbinden der Datensätze des Bundesfernstraßennetzes mit den Zählstellen und den Unfällen\nBisher haben wir allen Unfällen den nächstgelegenen Autobahnabschnitt und die Entfernung zu diesem zugewiesen. Nun wollen wir wissen, wie viele Unfälle es pro Abschnitt gibt. Das machen wir mit “group_by()” und “summarise()”. Außerdem benennen wir die Spalte “abschnitt_id” mit “rename()” in “abschnitt_id” um, damit wir die Datensätze gleich sauber verknüpfen können.\n\nd_unfaelle_abschnitt_2023 &lt;- d_unfaelle_bab_2023 |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    d_unfaelle_2023 = n(),\n    .groups = \"drop\"\n  )\n\nNun können wir alle drei Datensätze (Bundesfernstraßennetz der Autobahnen, (mittlere) DTV an Dauerzählstellen und Summe von Unfällen je Abschnitt) zu einem Datensatz zusammenfügen. Das machen wir mit “left_join()”. Zudem lassen wir uns die Länge der Abschnitte von Metern in Kilometer umrechnen.\n\nd_bfstn_gesamt &lt;- d_bfstn |&gt;\n  mutate(abschnitt_id = row_number()) |&gt;\n  mutate(laenge_km = as.numeric(Sk_Laenge_m)/1000) |&gt;\n  left_join(d_dzs_abschnitt_2023, by = \"abschnitt_id\") |&gt;\n  left_join(d_unfaelle_abschnitt_2023, by = \"abschnitt_id\") |&gt;\n  select(Str_Kennung, laenge_km, DTV_2023, d_unfaelle_2023, abschnitt_id)\n\n\n\n3.2.1.2 Unfallraten berechnen\nAls erstes legen wir unseren Zeitraum “t1” als 1 (Jahr) fest.\n\nt1 = 1\n\nAnschließend fügen wir dem Datensatz mit “mutate()” eine weitere Spalte mit dem Namen “unfallrate” hinzu, deren Werte mit der Formel für die Unfallrate berechnet werden.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(unfallrate = d_unfaelle_2023 * 10^6 / (DTV_2023 * laenge_km * 365  * t1)) \n\n\n\n3.2.1.3 Unfallraten auf der A38\nFür unsere gewählte Autobahn 38 erstellen wir einen neuen Datensatz. Das erst so spät zu machen, ermöglicht uns, dass wir bei Bedarf recht einfach (z.B. mit Suchen und Ersetzen) unsere Auswahl verändern könnten oder uns auch alle Unfallraten auf allen deutschen Bundesautobahnen darstellen lassen könnten.\n\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\nNun kommen wir zur grafischen Darstellung. Wir wollen im Hintergrund den Verlauf der A38 sehen, daher filtern wir uns aus dem Datensatz der Bundesautobahnen “d_bfstn” die Autobahn 38. Außerdem wollen wir uns drei Städte entlang der A38 für mehr Kontext darstellen. Dafür suchen wir uns die Koordinaten der Städte aus dem Internet. Diese sind allerdings in dem Koordinatenreferenzsystem 4326, daher transformieren (“st_transform”) wir sie in das CRS der anderen Daten (25832). In unserem ggplot stellen wir nun den Verlauf der A38 (“data = d_A38”) und die Städte (“data = d_staedte”) dar und beschriften die Städte mit “geom_sf_text()”. Und nun kommen endlich die Daten der Unfallraten. Diese filtern wir, dass nur Abschnitte mit Werten angezeigt werden (“filter(!is.na())”). Das machen wir erst hier und nicht schon eher, um die Zeilen nicht grundsätzlich aus dem Datensatz entfernen wollen, weil wir damit noch weiterrechnen. Für die Barrierefreiheit nutzen wir die Farbskala “scale_color_viridis_b” und beschriften unser Diagramm.\n\nd_A38 &lt;- d_bfstn |&gt; filter(Str_Kennung == \"A38\")\nd_staedte &lt;- st_as_sf(\n  tibble::tribble(\n  ~stadt, ~lat, ~lon,\n  \"Leipzig\", 51.3402, 12.3601,\n  \"Nordhausen\", 51.5018, 10.7957,\n  \"Göttingen\", 51.5455, 9.9055,\n  ),\n  coords = c(\"lon\", \"lat\"),\n  crs = 4326\n) |&gt;\n  st_transform(25832)\n\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label = stadt), nudge_y = 5000) +\n  geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfallrate)), \n    size = 2.5, \n    mapping = aes(color = unfallrate)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallrate\\n(Unfälle pro\\n1 Mio. Kfz-km)\") +\n  labs(title = \"Unfallraten nach Abschnitten der A38 im Jahr 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nWir sehen, dass viele Abschnitte eine Unfallrate von unter 0,12 Unfällen pro 1 Million Kfz-km aufweisen. Der (sehr schmale) Abschnitt bei Nordhausen zeigt hingegen eine Unfallrate von über 0,16 Unfällen pro 1 Million Kfz-km. Ein Blick in den Datensatz zeigt uns, dass dieser Abschnitt nur 585 Meter lang ist. Dadurch fallen einzelne Unfälle dort deutlich stärker ins Gewicht. Bei der Interpretation unserer Ergebnisse müssen wir daher stets unseren technischen Sachverstand einbringen und die Ergebnisse in den jeweiligen Kontext einordnen.\n\n\n\n3.2.2 Die Unfalldichte UD\n“Die [Unfalldichte] ist ein Maß für die (längenbezogene) Häufigkeit, mit der sich Unfälle während eines bestimmten Zeitraums auf einem bestimmten Straßenabschnitt ereignet haben” (FGSV 2003, 6). Dementsprechend lautet die Formel:\n\\[\nUD = \\frac{U}{L \\cdot t}\n\\]\nDa wir schon viel Vorarbeit geleistet haben, können wir zur Berechnung der Unfalldichte unserem Datensatz einfach eine weitere Spalte mit dem Namen “unfalldichte” und der Formel zur Berechnung der Unfalldichte hinzufügen.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(unfalldichte = d_unfaelle_2023 / (laenge_km * t1))                             \n\nAuch für die Unfalldichte schauen wir uns unsere ausgewählte Autobahn 38 an.\n\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\nDie grafische Darstellung übernehmen wir von der Unfallrate und tauschen nur die Variablen und die Beschriftungen aus. Jedoch ergänzen wir noch Grenzen bei der Beschriftung, da uns die Darstellung damit besser gefällt.\n\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfalldichte)), \n    size = 2.5, \n    mapping = aes(color = unfalldichte)\n    ) +\n  scale_color_viridis_b(direction = -1, limits = c(0, 10),  name = \"Unfalldichte\\n(Unfälle pro\\nkm und Jahr)\") +\n  labs(title = \"Unfalldichten nach Abschnitten der A38 im Jahr 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nIm Gegensatz zur Unfallrate sehen wir deutlich mehr farbige Abschnitte. Das liegt daran, dass die Unfalldichte unabhängig von der DTV ist und wir daher auch Abschnitte ohne Zählstellen darstellen können. Die große Mehrheit der Abschnitte hat eine Unfalldichte von unter 2,5 Unfällen pro Kilometer und Jahr. Wir sehen aber auch hier die Auswirkung von kurzen Abschnitten, diese haben tendenziell höhere Unfalldichten als längere Abschnitte.\n\n\n3.2.3 Die Unfallkostenrate UKR\n“Unfallkostenraten UKR beschreiben die entsprechenden durchschnittlichen volkswirtschaftlichen Kosten durch Straßenverkehrsunfälle, die bei einer Fahrleistung von 1000 Kfz-km in diesem Straßenabschnitt entstanden sind.” (FGSV 2003, 5). Die Formel lautet entsprechend:\n\\[\nUKR = \\frac{1000 \\cdot UK}{365 \\cdot DTV \\cdot L \\cdot t}\n\\]\nDie Unfallkosten UK werden über einen Betrachtungszeitraum von drei Jahren berechnet. Je nachdem, welche Unfalldaten vorliegen, werden unterschiedliche Formeln angewandt. Da aus dem Unfallatlas nur Unfälle mit Personenschaden und keine mit Sachschäden zur Verfügung stehen, wird die folgende Formel verwendet:\n\\[\nUK = U(SP) * WU(SP) + U(LV) * WU(LV)\n\\]\nmit\n\nU(SP) : Unfälle mit schwerem Personenschaden (Schwerverletzte und Getötete)\nWU(SP) : Unfallkostensatz von Unfällen mit schwerem Personenschaden\nU(LV) : Unfälle mit leichtem Personenschaden\nWU(LV) : Unfallkostensatz von Unfällen mit leichtem Personenschaden\n\nDie Unfallkostensätze werden den Empfehlungen für die Sicherheitsanalyse von Straßennetzen (FGSV 2003) entnommen.\n\n3.2.3.1 Schritt 1: Unfalldaten\nAls erstes werden die Unfalldaten der Jahre 2023, 2022 und 2021 in das Projekt geladen, mit “bind_rows” zusammengefügt und aufbereitet (analog zur Aufbereitung der Unfalldaten in 2023 am Anfang).\n\nd_unfaelle_alle &lt;- bind_rows(\n  read.csv2(\"daten/Unfallorte2023_LinRef.csv\") |&gt; mutate(jahr = 2023),\n  read.csv2(\"daten/Unfallorte2022_LinRef.csv\") |&gt; mutate(jahr = 2022),\n  read.csv2(\"daten/Unfallorte2021_LinRef.csv\") |&gt; mutate(jahr = 2021),\n  ) |&gt;\n  st_as_sf(coords = c(\"LINREFX\", \"LINREFY\"), crs = 25832) |&gt;\n  st_zm()\n\nWie auch bei den Unfalldaten aus 2023 fügen wir den Unfalldaten den nächstgelegenen Autobahnabschnitt und die Entfernung zu diesem hinzu und filtern nach allen Unfällen, die maximal 20 Meter von einem Autobahnabschnitt entfernt sind.\n\nd_unfaelle_bab_alle &lt;- d_unfaelle_alle |&gt;\n  mutate(\n    abschnitt_id = st_nearest_feature(geometry, d_bfstn),\n      distanz = st_distance(geometry, d_bfstn[abschnitt_id, ], by_element = TRUE),\n      name = d_bfstn$Str_Kennung[abschnitt_id]\n    ) |&gt;\n  filter(as.double(distanz) &lt;= 20) |&gt;\n  select(UKATEGORIE, name, abschnitt_id, jahr)\n\nEbenfalls wie bei den Unfalldaten aus 2023 fassen wir die Unfalldaten je Abschnitt zusammen. Da wir gleich für die Unfallkosten aber auch die Unfallkategorie berücksichtigen werden, gruppieren wir nicht nur nach Abschnitten, sondern auch nach den Unfallkategorien.\n\nd_unfaelle_abschnitt_alle &lt;- d_unfaelle_bab_alle |&gt;\n  st_set_geometry(NULL) |&gt;\n    group_by(abschnitt_id, UKATEGORIE) |&gt;\n    summarise(\n      Unfaelle = n(),\n      .groups = \"drop\"\n  ) \n\nNun wollen wir wissen, wie viele schwere und leichte Unfälle es je Abschnitt gibt. Schwere Unfälle sind Unfälle mit Schwerverletzten (Kategorie 2) und Getöteten (Kategorie 1). Leichte Unfälle sind die Unfallkategorie 3. Dazu filtern wir nach der oder den jeweiligen Kategorie, gruppieren nach Abschnitten und summieren die Unfallzahlen.\n\nd_unfaelle_sp_3j &lt;- d_unfaelle_abschnitt_alle |&gt;\n  filter(UKATEGORIE %in% c(1, 2)) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    unfaelle_sp_summe_3j = sum(Unfaelle, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nd_unfaelle_lv_3j &lt;- d_unfaelle_abschnitt_alle |&gt;\n  filter(UKATEGORIE == 3) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    unfaelle_lv_summe_3j = sum(Unfaelle, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nDiese beiden neuen Datensätze fügen wir als Spalten zu einem gemeinsamen Datensatz zusammen. Dabei ergänzen wir noch, dass wenn es keine Unfälle gibt, nicht “NA” in der Zelle steht, sondern 0, da das hier im Sachzusammenhang sinnvoll ist und wir dann später besser damit rechnen können.\n\nd_unfaelle_gesamt &lt;- d_unfaelle_sp_3j |&gt;\n  full_join(d_unfaelle_lv_3j, by = \"abschnitt_id\") |&gt;\n  mutate(\n    unfaelle_sp_summe_3j = replace_na(unfaelle_sp_summe_3j, 0),\n    unfaelle_lv_summe_3j = replace_na(unfaelle_lv_summe_3j, 0)\n  )\n\nDie Unfalldaten nach Abschnitten aus den drei beobachteten Jahren fügen wir nun dem großen Datensatz hinzu.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(abschnitt_id = row_number()) |&gt;\n  left_join(d_unfaelle_gesamt, by = \"abschnitt_id\") |&gt;\n  select(Str_Kennung, laenge_km, DTV_2023, d_unfaelle_2023, abschnitt_id, laenge_km, unfallrate, unfalldichte, unfaelle_sp_summe_3j, unfaelle_lv_summe_3j)\n\n\n\n3.2.3.2 Schritt 2: Dauerzählstellen\nAuch bei den Dauerzählstellen beginnen wir wieder mit dem laden, zusammenführen und aufbereiten der Daten. Dabei achten wir auf die richtige Encodierung.\n\nd_dzs_alle &lt;- bind_rows(\n  read_csv2(\"daten/Jawe2023.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt; mutate(jahr = 2023),\n  read_csv2(\"daten/Jawe2022.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt; mutate(jahr = 2022),\n  read_csv2(\"daten/Jawe2021.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt; mutate(jahr = 2021),\n  ) |&gt;\n  st_as_sf(coords =  c(\"Koor_UTM32_E\", \"Koor_UTM32_N\"),  crs = 25832) |&gt;\n  st_zm()\n\nAuch im nächsten Schritt gehen wir wie am Anfang vor, filtern nach Zählstellen auf Autobahnen, ignorieren Zählstellen ohne Zähldaten, achten auf das richtige CRS und fügen eine Spalte zum nächstgelegenen Autobahnabschnitt hinzu.\n\nd_dzs_bab_alle &lt;- d_dzs_alle|&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  mutate(abschnitt_id = st_nearest_feature(geometry, d_bfstn))\n\nNun fassen wir die DTV-Daten auf Abschnittsebene zusammen und bilden Mittelwerte der DTV.\n\nd_dzs_abschnitt_alle &lt;- d_dzs_bab_alle |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(DTV = mean(DTV_Kfz_MobisSo_Q, na.rm = TRUE))\n\nIm Gegensatz zu den Unfalldaten, die aufsummiert werden, wird methodisch bei der durchschnittlichen täglichen Verkehrsstärke der Mittelwert je Abschnitt gebildet.\n\nd_dzs_gesamt &lt;- d_dzs_abschnitt_alle |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    dtv_mittelwert_3j = round(mean(DTV, na.rm = TRUE)),\n    .groups = \"drop\"\n  )\n\nNun können wir die DTV-Daten dem Datensatz des Bundesfernstraßennetzes hinzufügen.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  left_join(d_dzs_gesamt, by = \"abschnitt_id\")\n\n\n\n3.2.3.3 Schritt 3: Unfallkostensätze definieren\nDie Unfallkostensätze werden nach den ESN (FGSV 2003) definiert. Dabei wird für die schweren Personenunfälle der Mittelwert aus den Bundesländern Sachsen, Sachsen-Anhalt, Thüringen, Niedersachsen gebildet, da die A38 durch diese vier Bundesländer verläuft. Die Länge je Bundesland wird hierbei außer Acht gelassen.\n\nWU_SP_bab = 325000\nWU_LV_bab = 31000\nt2 = 3\n\n\n\n3.2.3.4 Schritt 4: Unfallkostenraten berechnen\nWie bei der Unfallrate und -dichte fügen wir nun eine Spalte zur Unfallkostenrate dem großen Datensatz hinzu. Dafür nutzen wir einen Zwischenschritt und erstellen uns erst noch eine Spalte zu den Unfallkosten.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(\n    unfallkosten = unfaelle_sp_summe_3j * WU_SP_bab + unfaelle_lv_summe_3j * WU_LV_bab ,\n    unfallkostenrate = (1000*unfallkosten)/(365*dtv_mittelwert_3j*laenge_km*t2)\n  )\n\n\n\n3.2.3.5 Schritt 5: Ausgewählte Autobahn\n\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\n\n\n3.2.3.6 Schritt 6: Grafische Darstellung\n\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfallkostenrate)), \n    size = 2.5, \n    mapping = aes(color = unfallkostenrate)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallkostenrate\\n(Euro pro\\n1000 Kfz und km und Jahr)\") +\n  labs(title = \"Unfallkostenraten nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nWir sehen, dass viele Abschnitte eine Unfallkostenrate von unter 15 Euro pro 1000 Kfz und km und Jahr haben. Auffällig ist ein Abschnitt zwischen Nordhausen und Göttigen. Ein Blick in den Datensatz verrät, dass es hier innerhalb der drei beobachteten Jahre 10 schwere und 4 leichte Unfälle auf etwa 6,5 km Länge und bei etwa 22.000 Kfz pro Tag gab.\n\n\n\n3.2.4 Unfallkostendichte UKD\nDie Unfallkostendichte UKD beschreibt “die mittleren volkswirtschaftlichen Kosten durch Straßenverkehrsunfälle, die auf 1 km Länge des Straßenabschnittes entfallen” (FGSV 2003, 6).\nDie Formel lautet:\n\\[\nUKD = \\frac{UK}{1000 \\cdot L \\cdot t}\n\\]\nDa die Unfallkosten bereits berechnet sind, ist die Berechnung der Unfallkostendichte nun schneller.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(unfallkostendichte = unfallkosten/(1000*laenge_km*t2))\n\n\nd_A38_gesamt &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\n\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(unfallkostendichte)), \n    size = 2.5, \n    mapping = aes(color = unfallkostendichte)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallkostendichte\\n(1000 Euro pro\\nkm und Jahr)\") +\n  labs(title = \"Unfallkostendichten nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\n3.2.5 Sicherheitspotenzial SIPO\n“Das Sicherheitspotenzial SIPO eines Straßenabschnittes ist definiert als Unterschied zwischen den Unfallkosten (Anzahl und Schwere der Unfälle), die bei richtliniengerechtem Ausbau zu erwarten wären, und den vorhandenen Unfallkosten. […] Kenngröße für das Sicherheitspotenzial SIPO ist die Differenz zwischen der vorhandenen Unfallkostendichte UKD eines Netzabschnittes im Betrachtungszeitraum und der Grundunfallkostendichte gUKD.” (FGSV 2003, 8f.)\n\\[\nSIPO = UKD - gUKD\n\\]\nDie Grundunfallkostendichte gUKD wird mit der folgenden Formel berechnet:\n\\[\ngUKD = \\frac{gUKR \\cdot DTV \\cdot 365}{10^6}\n\\]\nmit der Grundunfallkostenrate gUKR, die den ESN (FGSV 2003) zu entnehmen ist.\n\ngUKR_bab = 11\n\nWir fügen wie bei den vorherigen Kenngrößen neue Spalten mit den Berechnungen hinzu.\n\nd_bfstn_gesamt &lt;- d_bfstn_gesamt |&gt;\n  mutate(\n    gUKD = (gUKR_bab * dtv_mittelwert_3j * 365)/10^6,\n    sicherheitspotenzial = unfallkostendichte - gUKD\n)\n\nUnd filtern nach unserer Beispielautobahn.\n\nd_A38_gesamt  &lt;- d_bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\n\nggplot () +\n  geom_sf(data = d_A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = d_staedte, color = \"red\") +\n  geom_sf_text(data = d_staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = d_A38_gesamt |&gt; filter(!is.na(sicherheitspotenzial)), \n    size = 2.5, \n    mapping = aes(color = sicherheitspotenzial)\n    ) +\n  scale_color_viridis_b(direction = -1, breaks = c(0, 50, 100), name = \"Sicherheitspotenzial\\n(1000 Euro pro\\nkm und Jahr)\") +\n  labs(title = \"Sicherheitspotenziale nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nEin Sicherheitspotenzial, dass kleiner gleich 0 ist, bedeutet, dass die Unfallkostendichte geringer als oder gleich der Grundunfallkostendichte ist. Das heißt, dass hier weniger (schwere) Unfälle aufgetreten sind, als aufgrund des Ausbaus zu erwarten wären. Das ist also etwas positives, hier gibt es (zumindest für den beobachteten Zeitraum) wenig Handlungsdruck. Je größer das Sicherheitspotenzial ist, desto mehr Bedarf besteht, die Infrastruktur sicherer zu gestalten. In unserer Grafik ist das vor allem der Abschnitt zwischen Nordhausen und Göttingen (SIPO zwischen 50 und 100), der schon bei der Unfallkostenrate auffällig war, sowie drei Abschnitte zwischen Nordhausen und Leipzig die ein Sicherheitspotential zwischen 0 und 50 haben.\n\n\n\n\nFGSV. 2003. Empfehlungen für die Sicherheitsanalyse von Straßennetzen (ESN). Köln: Forschungsgesellschaft für Straßen- und Verkehrswesen (FGSV).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Musterlösung mit Erläuterungen</span>"
    ]
  }
]