[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "",
    "text": "Einleitung",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nZum erfolgreichen Bearbeiten dieses Anwendungsbausteins benötigen Sie die Inhalte des Methodenbausteins Grundlagen der Statistik [Referenz] To-Do und des Werkzeugbausteins R [Referenz] To-Do. Außerdem sollten Grundbegriffe der verkehrlichen Sicherheitsanalyse wie die Unfallrate, Unfalldichte, Unfallkosten und Sicherheitspotentiale bekannt sein.",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nZiel dieses Bausteins ist es, typische Inhalte von sicherheitsrelevanten Fragestellungen von Verkehrsnetzen in grafischer Form mithilfe der Programmiersprache R darzustellen. Dabei lernen Sie wo deutschsprachige Unfalldaten gefunden werden können, wie Unfalldaten eingelesen, aufbereitet und analysiert werden und welche verschiedenen Darstellungsformen sich für bestimmte Datentypen eignen.",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#verwendete-datensätze",
    "href": "index.html#verwendete-datensätze",
    "title": "Anwendungsbaustein Sicherheitsanalyse",
    "section": "Verwendete Datensätze",
    "text": "Verwendete Datensätze\nDaten des Straßennetzes des Bundesinformationssystem Straße (BISStra) der Bundesanstalt für Straßen- und Verkehrswesen (BASt)\nUnfalldaten des Unfallatlas des Statistischen Bundesamts\nVerkehrsmengen der Dauerzählstellen der BASt",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "aufgabe/aufgaben_sicherheitsanalyse.html",
    "href": "aufgabe/aufgaben_sicherheitsanalyse.html",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "",
    "text": "2 Datenquellen\nDie statistischen Ämter des Bundes und der Länder erheben und veröffentlichen mit der Straßenverkehrsunfallstatistik die Verkehrsunfälle mit Personenschaden oder Sachschaden in Deutschland. Im Unfallatlas werden Unfälle mit Personenschaden geführt. Für die Sicherheitsanalyse von Verkehrsnetzen können diese Daten verwendet und analysiert werden.\nVerwenden Sie für das Straßennetz die Daten des Bundesinformationssystems Straße (BISStra) der Bundesanstalt für Straßen- und Verkehrswesen (BASt).\nDie durchschnittliche Verkehrsstärke (DTV) auf Autobahnen kann ebenfalls über die BASt unter dem Stichwort “Dauerzählstellen” bezogen werden.\nDie Formeln der Kenngrößen für die Sicherheitsbewertung werden den Empfehlungen für die Sicherheitsanalyse von Straßennetzen (ESN) (2003) der Forschungsgesellschaft für Straßen- und Verkehrswesen (FGSV) entnommen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabe/aufgaben_sicherheitsanalyse.html#aufgabe-1-anzahl-der-verkehrsunfälle",
    "href": "aufgabe/aufgaben_sicherheitsanalyse.html#aufgabe-1-anzahl-der-verkehrsunfälle",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "2.1 Aufgabe 1 : Anzahl der Verkehrsunfälle",
    "text": "2.1 Aufgabe 1 : Anzahl der Verkehrsunfälle\nErstellen Sie eine tabellarische Übersicht der Unfallzahlen nach Unfallkategorie für eine ausgewählte Autobahn und für Gesamtdeutschland in einem frei wählbaren Jahr.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabe/aufgaben_sicherheitsanalyse.html#aufgabe-2-unfallkenngrößen-auf-autobahnen",
    "href": "aufgabe/aufgaben_sicherheitsanalyse.html#aufgabe-2-unfallkenngrößen-auf-autobahnen",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "2.2 Aufgabe 2 : Unfallkenngrößen auf Autobahnen",
    "text": "2.2 Aufgabe 2 : Unfallkenngrößen auf Autobahnen\nStellen Sie die folgende Unfallkenngrößen für eine ausgewählte Autobahn in einem frei wählbaren Jahr grafisch dar:\n\ndie Unfallrate UR,\ndie Unfalldichte UD,\ndie Unfallkostenrate UKR,\ndie Unfallkostendichte UKD und\ndas Sicherheitspotential SIPO",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabe/aufgaben_sicherheitsanalyse.html#to-do-optional-aufgabe-3-unfallkenngrößen-auf-stadtstraßen",
    "href": "aufgabe/aufgaben_sicherheitsanalyse.html#to-do-optional-aufgabe-3-unfallkenngrößen-auf-stadtstraßen",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "2.3 To-Do Optional: Aufgabe 3 : Unfallkenngrößen auf Stadtstraßen",
    "text": "2.3 To-Do Optional: Aufgabe 3 : Unfallkenngrößen auf Stadtstraßen\nStellen Sie die folgende Unfallkenngrößen sowohl für eine ausgewählte Stadt in einem frei wählbaren Jahr grafisch dar:\n\ndie Unfallrate UR,\ndie Unfalldichte UD,\ndie Unfallkostenrate UKR,\ndie Unfallkostendichte UKD und\ndas Sicherheitspotential SIPO",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "musterloesung.html",
    "href": "musterloesung.html",
    "title": "2  Musterlösung Sicherheitsanalyse",
    "section": "",
    "text": "2.1 Aufgabe 1 : Unfälle zählen\nVerwendete Pakete laden\nDaten einlesen und aufbereiten\nDeutschlandkarte:\nUnfalldaten:\nStreckenabschnitte:\nStreckenabschnitte A43:\nStreckenabschnitte Deutschland:\nUnfälle filtern:\nAlles nicht in der Nähe von A43 raus:\nUnfälle zählen:\nVerbinden mit Daten der A43:\nAnzahl der Unfälle in ggplot plotten:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Sicherheitsanalyse</span>"
    ]
  },
  {
    "objectID": "musterloesung.html#aufgabe-1-unfälle-zählen",
    "href": "musterloesung.html#aufgabe-1-unfälle-zählen",
    "title": "2  Musterlösung Sicherheitsanalyse",
    "section": "",
    "text": "```{r}\nunfaelle_43 = unfaelle %&gt;%\n    # find out which autobahn is closest by\n    mutate(nearest_autobahn_id = st_nearest_feature(st_zm(.), a43)) %&gt;% \n    # calculate distance to closest autobahn\n    mutate(nearest_autobahn_distance = st_distance(st_zm(.), a43[nearest_autobahn_id, ], by_element = TRUE))\n```\n\n```{r}\nunfaelle_autobahn = unfaelle_43 |&gt; \n    filter(as.double(nearest_autobahn_distance) &lt;= 15) |&gt;\n  st_zm()\n```\n\n```{r}\nautobahnen_accident_count = unfaelle_autobahn %&gt;% \n    as_tibble() %&gt;% \n    select(-geometry) %&gt;%\n    count(nearest_autobahn_id, UKATEGORIE) %&gt;% \n  spread(UKATEGORIE, n) %&gt;%\n  rename(Anzahl_UK2 = `2`, Anzahl_UK3 = `3`) %&gt;%\n  replace(is.na(.), 0) %&gt;%\n  mutate(Anzahl_U_G = Anzahl_UK2 + Anzahl_UK3)\n# Hier gehören eigentlich noch Unfaelle nach Kategorie 1 rein\n```\n\n```{r}\na43 = a43 |&gt; \n    left_join(autobahnen_accident_count, by = c(\"rownumber\" = \"nearest_autobahn_id\"))\n\na43 &lt;- replace(a43, is.na(a43), 0)\n```\n\n```{r}\nggplot () +\n  geom_sf(data = a43, size = 2, mapping = aes(color = Anzahl_U_G)) +\n  scale_color_viridis_b(direction = -1, breaks = seq(2,14,2)) +\n  labs(title = \"Anzahl der Verkehrsunfälle nach Abschnitten der A43 im Jahr 2022\",\n       color = \"Anzahl Verkehrsunfälle\") +\n theme(plot.title = element_text(size=10))\n```",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Sicherheitsanalyse</span>"
    ]
  },
  {
    "objectID": "musterloesung.html#aufgabe-2",
    "href": "musterloesung.html#aufgabe-2",
    "title": "2  Musterlösung Sicherheitsanalyse",
    "section": "2.2 Aufgabe 2",
    "text": "2.2 Aufgabe 2\n\n2.2.1 Unfalldichte\n\n2.2.1.1 A43\nUnfälle filtern:\n```{r}\nunfaelle_43 = unfaelle %&gt;%\n    # Welche Autobahn am Nächsten\n    mutate(nearest_autobahn_id = st_nearest_feature(st_zm(.), a43)) %&gt;% \n    # Distanz zur A43\n    mutate(nearest_autobahn_distance = st_distance(st_zm(.), a43[nearest_autobahn_id, ], by_element = TRUE))\n```\nAlles nicht in der Nähe von A43 raus:\n```{r}\nunfaelle_autobahn = unfaelle_43 |&gt; \n    filter(as.double(nearest_autobahn_distance) &lt;= 15) |&gt;\n  st_zm()\n```\nUnfälle zählen:\n```{r}\nautobahnen_accident_count = unfaelle_autobahn %&gt;% \n    as_tibble() %&gt;% \n    select(-geometry) %&gt;%\n    count(nearest_autobahn_id, UKATEGORIE) %&gt;% \n  spread(UKATEGORIE, n) %&gt;%\n  rename(Anzahl_UK2 = `2`, Anzahl_UK3 = `3`) %&gt;%\n  replace(is.na(.), 0) %&gt;%\n  mutate(Anzahl_U_G = Anzahl_UK2 + Anzahl_UK3)\n# Hier gehören eigentlich noch Unfaelle nach Kategorie 1 rein, existieren aber in diesem Zeitraum nicht.\n```\nVerbinden mit Daten der A43:\n```{r}\na43 = a43 |&gt; \n    left_join(autobahnen_accident_count, by = c(\"rownumber\" = \"nearest_autobahn_id\"))\n```\nPlotten:\n```{r}\nggplot () +\n  geom_sf(data = a43, size = 2, mapping = aes(color = Anzahl_U_G)) +\n  scale_color_distiller(palette = 8 , direction = 1, breaks = seq(2,14,2)) +\n  labs(title = \"Anzahl der Verkehrsunfälle nach Abschnitten der A43 im Jahr 2022\",\n       color = \"Anzahl Verkehrsunfälle\") +\n theme(plot.title = element_text(size=10))\n```\n\n\n2.2.1.2 Deutschland\nUnfälle filtern:\n```{r}\nunfaelle_de = unfaelle %&gt;%\n    # Welche Autobahn ist am Nächsten\n    mutate(nearest_autobahn_id = st_nearest_feature(st_zm(.), strecke_de)) %&gt;% \n    # Distanz zur nächsten Autobahn berechnen\n    mutate(nearest_autobahn_distance = st_distance(st_zm(.), strecke_de[nearest_autobahn_id, ], by_element = TRUE))\n```\nAlles nicht in der Nähe von BAB raus:\n```{r}\nunfaelle_de_autobahn = unfaelle_de |&gt; \n    filter(as.double(nearest_autobahn_distance) &lt;= 15) |&gt;\n  st_zm()\n```\nUnfälle zählen:\n```{r}\nde_unfall_anzahl = unfaelle_de_autobahn %&gt;% \n    as_tibble() %&gt;% \n    select(-geometry) %&gt;%\n    count(nearest_autobahn_id, UKATEGORIE) %&gt;% \n  spread(UKATEGORIE, n) %&gt;%\n  rename(Anzahl_UK1 = `1`,Anzahl_UK2 = `2`, Anzahl_UK3 = `3`) %&gt;%\n  replace(is.na(.), 0) %&gt;%\n  mutate(Anzahl_U_G = Anzahl_UK1 + Anzahl_UK2 + Anzahl_UK3)\n```\nVerbinden mit Daten:\n```{r}\nstrecke_de = strecke_de |&gt; \n    left_join(de_unfall_anzahl, by = c(\"rownumber\" = \"nearest_autobahn_id\"))\n\nstrecke_de = strecke_de |&gt;\n  mutate(UD = (Anzahl_U_G)/(Sk_Laenge_km))\n```\nPlotten:\n```{r}\nggplot () +\n  geom_sf(data = d_de, fill = NA, size = 0.5) +\n  geom_sf(data = strecke_de, size = 2, mapping = aes(color = Anzahl_U_G)) +\n  scale_color_distiller(palette = 8 , direction = 1) +\n  labs(title = \"Anzahl der Verkehrsunfälle nach Abschnitten der BAB im Jahr 2022\",\n       color = \"Anzahl Verkehrsunfälle\") +\n theme(plot.title = element_text(size=10))\n```\n\n\n\n2.2.2 Unfallrate\n\n2.2.2.1 A43\n\n\n\n2.2.3 Deutschland",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Sicherheitsanalyse</span>"
    ]
  },
  {
    "objectID": "sicherheitsanalyse.html",
    "href": "sicherheitsanalyse.html",
    "title": "3  Musterlösung mit Erläuterungen",
    "section": "",
    "text": "3.1 Aufgabe 1 : Anzahl der Verkehrsunfälle\nAls frei wählbare Jahr wird 2023 gewählt und als frei wählbare Autobahn die A38.\nAls erstes werden die Daten vom Unfallatlas heruntergeladen und in R geladen. Danach wird der Datensatz mit “st_as_sf” in ein räumliches Punktobjekt umgewandelt. Die Koordinaten stammen aus den Spalten “LINREFX” und “LINREFY”. Mit CRS (Coordinate Reference System) wird das Koordinatenreferenzsystem EPSG:25832 definiert. Falls sich in den geometrischen Daten noch Informationen zur Höhe (z-Dimension) oder Messwerte oder Attribute (m-Dimension) enthalten sind, werden diese nun entfernt, damit wir gleich sauber mit ihnen weiterrechnen können.\nunfaelle_2023 = read_csv2(\"data/Unfallorte2023_LinRef.csv\") |&gt;\n  st_as_sf(coords = c(\"LINREFX\", \"LINREFY\"), crs = 25832) |&gt;\n  st_zm()\nAls nächstes wird das Straßennetz der Bundesfernstraßen als Datensatz ins Projekt geladen. Diese Daten bekommen wir von der Bundesanstalt für Straßen- und Verkehrswesen (BASt). Das Bundesfernstraßennetz beinhaltet Daten zu Bundesautobahnen und Bundesstraßen. Da für uns nur die Autobahnen relevant sind, filtern wir nur diese heraus. Wir wählen als Achse die Bestandsachse, da dies die mittlere Achse der Straße ist und wir keine Unterscheidung der Fahrtrichtung vornehmen müssen. Wir ergänzen eine Spalte (“mutate”) mit der Zeilennummer (brauchen wir gleich für die Unfälle). Auch hier entfernen wir potentielle Daten der z- oder m-Dimension.\nbfstn &lt;- read_sf(\"data/BFStr_Netz_v2025q3.gpkg\") |&gt;\n  filter(Str_Klasse_kurz == \"A\" & Sk_Achse == \"Bestandsachse\") |&gt;\n  mutate(rownumber = row_number()) |&gt;\n  st_zm()\nDen Unfalldaten soll nun aufgrund ihrer Lage in Deutschland der nächstgelegene Autobahnabschnitt und die Entfernung zu diesem hinzugefügt werden. “st_nearest_feature” gibt dabei die Zeilennummer des nächstgelegenen Autobahnabschnitts im Datensatz “bfstn” wieder. “st_dinstance” berechnet die Entfernung vom Unfallpunkt zum nächstgelegenen Autobahnabschnitt, dies kann unter Umständen länger dauern. Außerdem suchen wir mit “bfstn$Str_Kennung[abschnitt_id]” aus dem Datensatz “bfstn” und der Spalte “Str_Kennung” genau den Eintrag, dessen Zeile durch “abschnitt_id” angegeben wird. Damit bekommen wir statt einer Nummer eines Autobahnabschnittes den Namen der Autobahn (z.B. A1). Zudem wollen wir nur Unfälle, die auf Autobahnen passiert sind, berücksichtigen. Dafür filtern wir nach Unfällen, die in einem 20 m Umkreis zur Bestandsachse der Autobahnen sind. Die 20 m wählen wir, um fast alle Unfälle auf den Fahrbahnen, auch bei 6- oder 8-spurigen Autobahnen, einzuschließen und fast alle Unfälle daneben auszuschließen. Es gibt uns aber keine Garantie, dass alle Unfälle, die wir nun filtern, tatsächlich auf Autobahnen liegen. Den Unterschied des Filters sehen wir im Environment: Der Unfalldatensatz aus 2023 beinhaltet 269.048 Unfälle insgesamt, der Unfalldatensatz für Autobahnen nur noch 22.114. Für mehr Übersichtlichkeit vereinfachen wir unseren Datensatz und lassen uns mit “select” nur bestimmte Spalten anzeigen.\nunfaelle_bab_2023 = unfaelle_2023 |&gt;\n    mutate(\n      nearest_autobahn_id = st_nearest_feature(geometry, bfstn),\n      nearest_autobahn_distance = st_distance(geometry, bfstn[nearest_autobahn_id, ], by_element = TRUE),\n      nearest_autobahn_name = bfstn$Str_Kennung[nearest_autobahn_id]\n    ) |&gt;\n  filter(as.double(nearest_autobahn_distance) &lt;= 20) |&gt;\n  rename(abschnitt_id = nearest_autobahn_id) |&gt;\n  select(UKATEGORIE, nearest_autobahn_name, abschnitt_id)\nFür die tabellarische Übersicht der Unfälle erstellen wir einen neuen Datensatz, der nur Unfälle auf der Autobahn 38 beinhaltet.\nunfaelle_A38_2023 = unfaelle_bab_2023 |&gt; \n    filter(nearest_autobahn_name == \"A38\")\nNun folgt die tabellarische Darstellung. Wir nutzen “function”, da wir sowohl für alle Unfälle auf deutschen Autobahnen als auch auf der A38 folgende Schritte durchführen wollen: Mit “st_set_geometry(NULL)” entfernen wir die Geometriespalte, da für die Auswertung in Tabellenform nur die Attributdaten benötigt werden. Anschließend gruppieren wir die Unfalldaten nach ihrer Kategorie (1, 2 oder 3) und berechnen mit “summarise” die Anzahl der Unfälle je Unfallkategorie. Um eine weitere Zeile mit den Summen hinzufügen zu können, muss die Spalte zur Unfallkategorie in einen Zeichenvektor umgewandelt werden (“mutate(UKATEGORIE = as.character(UKATEGORIE))”). Die neue Zeile hängen wir mit “bind_rows()” an. Diese letzte Zeile der Spalte UKATEGORIE („Summe“) enthält nun die Gesamtanzahl aller Unfälle über alle Kategorien hinweg und dient als übersichtliche Gesamtsumme in der Ergebnistabelle. Nun fügen wir die beiden einzelnen Tabellen noch zu einer Tabelle zusammen mit “left_join()” und benennen die Zeilennamen um. Mit “kable()” stellen wir die Tabelle dar und können ihr noch eine Überschrift hinzufügen.\nzaehle_unfaelle &lt;- function(daten, spaltenname) {\n  tmp &lt;- daten |&gt;\n    st_set_geometry(NULL) |&gt;\n    count(UKATEGORIE, name = spaltenname) |&gt;\n    mutate(UKATEGORIE = as.character(UKATEGORIE))\n\n  bind_rows(\n    tmp,\n    summarise(\n      tmp,\n      UKATEGORIE = \"Summe\",\n      \"{spaltenname}\" := sum(.data[[spaltenname]])\n    )\n  )\n}\n\ntabelle_unfaelle &lt;- left_join(\n  zaehle_unfaelle(unfaelle_A38_2023, \"A38\"),\n  zaehle_unfaelle(unfaelle_bab_2023, \"Autobahnen\"),\n  by = \"UKATEGORIE\"\n) |&gt;\n  rename(Unfallkategorie = UKATEGORIE) |&gt;\n  mutate(\n    Unfallkategorie = case_when(\n      Unfallkategorie == \"1\" ~ \"Unfall mit Getöteten\",\n      Unfallkategorie == \"2\" ~ \"Unfall mit Schwerverletzten\",\n      Unfallkategorie == \"3\" ~ \"Unfall mit Leichtverletzten\",\n      TRUE ~ Unfallkategorie\n    )\n  )\n\n\nkable(\n  tabelle_unfaelle,\n  caption = \"Anzahl der Verkehrsunfälle nach Unfallkategorie (A38 und alle deutschen Autobahnen) im Jahr 2023\"\n)\n\n\nAnzahl der Verkehrsunfälle nach Unfallkategorie (A38 und alle deutschen Autobahnen) im Jahr 2023\n\n\nUnfallkategorie\nA38\nAutobahnen\n\n\n\n\nUnfall mit Getöteten\n8\n282\n\n\nUnfall mit Schwerverletzten\n43\n3739\n\n\nUnfall mit Leichtverletzten\n132\n18093\n\n\nSumme\n183\n22114",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Musterlösung mit Erläuterungen</span>"
    ]
  },
  {
    "objectID": "sicherheitsanalyse.html#aufgabe-2-unfallkenngrößen-auf-autobahnen",
    "href": "sicherheitsanalyse.html#aufgabe-2-unfallkenngrößen-auf-autobahnen",
    "title": "3  Musterlösung mit Erläuterungen",
    "section": "3.2 Aufgabe 2 : Unfallkenngrößen auf Autobahnen",
    "text": "3.2 Aufgabe 2 : Unfallkenngrößen auf Autobahnen\n\n3.2.1 Die Unfallrate UR\n“Die Unfallrate ist ein Maß für das (fahrleistungsbezogene) Risiko des Verkehrsteilnehmers, in einen Unfall verwickelt zu werden oder dabei zu verunglücken.” (FGSV (2003), S. 5) Die Formel lautet\n\\[\nUR = \\frac{U \\cdot 10^6}{DTV \\cdot L \\cdot 365 \\cdot t}\n\\] mit den Kenngrößen\n\nU: Anzahl der Unfälle\nDTV : durchschnittliche tägliche Verkehrsstärke in Kraftfahrzeugen pro 24 Stunden [Kfz/24h oder Kfz/d]\nL : untersuchte Streckenlänge [km]\nt : untersuchter Zeitraum [a].\n\nDie DTV kann den Dauerzählstellen der BASt entnommen werden. Die Streckenlänge ist im Datensatz des Bundesfernstraßennetzes bereits enthalten.\nAls erstes laden wir die Daten der Dauerzählstellen in unser Projekt. Mit dem Argument “locale(encoding =”iso-8859-1”)” stellen wir sicher, dass Umlaute und Sonderzeichen, die in deutschsprachigen Datensätzen häufig vorkommen, korrekt eingelesen werden. Da wir die Dauerzählstellen später mit dem Bundesfernstraßennetz verknüpfen möchten, berücksichtigen wir wie bei den anderen Datensätzen ausschließlich Autobahnen. Dazu filtern wir nach der Straßenklasse “Str_Kl ==”A”“. Anschließend entfernen wir mit”drop_na(DTV_Kfz_MobisSo_Q)” alle Beobachtungen, für die keine Verkehrsstärkewerte vorliegen, sodass nur vollständige und auswertbare Zählstellen verbleiben. Im nächsten Schritt wird der Datensatz in ein sf-Objekt umgewandelt. Aus den Koordinatenspalten “Koor_UTM32_E” und “Koor_UTM32_N” werden Punktgeometrien mit dem gleichen Koordinatensystem wie bei den anderen Datensätzen erzeugt. Dadurch sind spätere räumliche Operationen kompatibel. Wie auch bei den anderen räumlichen Datensätzen entfernen wir anschließend mögliche z- und m-Dimensionen aus den Geometrien. Im nächsten Schritt werden die Dauerzählstellen wie bei den Unfällen den nächstgelegenen Autobahnabschnitten des Bundesfernstraßennetzes zugeordnet. Mit “st_nearest_feature()” wird für jede Zählstelle der Index des nächstgelegenen Abschnitts ermittelt und als “abschnitt_id” gespeichert. Im Gegensatz zu den Unfalldaten müssen wir keine Entfernung zur Autobahn ermitteln, weil wir wissen, dass die Zählstellen tatsächlich an Autobahnen sind.\n\ndzs_2023 &lt;- read_csv2(\"data/Jawe2023.csv\", locale = locale(encoding = 'iso-8859-1')) |&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  st_as_sf(coords =  c(\"Koor_UTM32_E\", \"Koor_UTM32_N\"),  crs = 25832) |&gt;\n  st_zm() |&gt;\n  mutate(abschnitt_id = st_nearest_feature(geometry, bfstn))\n\nBevor wir mit den Daten der Dauerzählstellen weiterrechnen, prüfen wir, ob jedem Autobahnabschnitt maximal eine Dauerzählstelle zugeordnet ist. In unserem Verständnis ist ein Autobahnabschnitt u.a. dadurch klassifiziert, dass in diesem keine Auffahrt oder Abfahrt vorhanden ist, daher würden zwei Zählstellen hier nur redudante DTV-Werte liefern. Bevor wir mit dieser Annahme weiterrechnen, kontrollieren wir sie.\n\ndzs_2023 |&gt;\n  st_drop_geometry() |&gt;\n  group_by(abschnitt_id) |&gt;\n  filter(n() &gt; 1) |&gt;\n  select(abschnitt_id, DZ_Nr, DTV_Kfz_MobisSo_Q)\n\n# A tibble: 2 × 3\n# Groups:   abschnitt_id [1]\n  abschnitt_id DZ_Nr DTV_Kfz_MobisSo_Q\n         &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;\n1        14490 6730              28566\n2        14490 6831              45945\n\n\nWir sehen, dass unsere Annahme falsch ist und es tatsächlich einen Abschnitt mit zwei Zählstellen gibt und beide auch tatsächlich unterschiedliches Verkehrsaufkommen gibt. Zwischen den Zählstellen scheint es also auch die Möglichkeit zu geben, auf die Autobahn auf- oder von ihr abzufahren. Daher fassen wir die Verkehrsstärken nun auf Abschnittsebene zusammen. Hierzu wird die Geometrie entfernt und wir berechnen den mittlere DTV-Wert (“mean”) von beiden Zählstellen je Abschnitt. Und auch bei diesem Datensatz reduzieren wir die Anzahl der Spalten für mehr Übersichtlichkeit.\n\ndzs_abschnitt_2023 &lt;- dzs_2023 |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    DTV_2023 = mean(DTV_Kfz_MobisSo_Q, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  select(abschnitt_id, DTV_2023)\n\n\n3.2.1.1 Verbinden der Datensätze des Bundesfernstraßennetzes mit den Zählstellen und den Unfällen\nBisher haben wir allen Unfällen den nächstgelegenen Autobahnabschnitt und die Entfernung zu diesem zugewiesen. Nun wollen wir wissen, wie viele Unfälle es pro Abschnitt gibt. Das machen wir mit “group_by()” und “summarise()”. Außerdem benennen wir die Spalte “nearest_autobahn_id” mit “rename()” in “abschnitt_id” um, damit wir die Datensätze gleich sauber verknüpfen können.\n\nunfaelle_abschnitt_2023 &lt;- unfaelle_bab_2023 |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    Unfaelle_2023 = n(),\n    .groups = \"drop\"\n  )\n\nNun können wir alle drei Datensätze (Bundesfernstraßennetz der Autobahnen, (mittlere) DTV an Dauerzählstellen und Summe von Unfällen je Abschnitt) zu einem Datensatz zusammenfügen. Das machen wir mit “left_join()”. Zudem lassen wir uns die Länge der Abschnitte von Metern in Kilometer umrechnen.\n\nbfstn_gesamt &lt;- bfstn |&gt;\n  mutate(abschnitt_id = row_number()) |&gt;\n  mutate(laenge_km = as.numeric(Sk_Laenge_m)/1000) |&gt;\n  left_join(dzs_abschnitt_2023, by = \"abschnitt_id\") |&gt;\n  left_join(unfaelle_abschnitt_2023, by = \"abschnitt_id\") |&gt;\n  select(Str_Kennung, laenge_km, DTV_2023, Unfaelle_2023, abschnitt_id)\n\n\n\n3.2.1.2 Unfallraten berechnen\nAls erstes legen wir unseren Zeitraum “t1” als 1 (Jahr) fest.\n\nt1 = 1\n\nAnschließend fügen wir dem Datensatz mit “mutate()” eine weitere Spalte mit dem Namen “unfallrate” hinzu, deren Werte mit der Formel für die Unfallrate berechnet werden.\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  mutate(unfallrate = Unfaelle_2023 * 10^6 / (DTV_2023 * laenge_km * 365  * t1)) \n\n\n\n3.2.1.3 Unfallraten auf der A38\nFür unsere gewählte Autobahn 38 erstellen wir einen neuen Datensatz. Das erst so spät zu machen, ermöglicht uns, dass wir bei Bedarf recht einfach (z.B. mit Suchen und Ersetzen) unsere Auswahl verändern könnten oder uns auch alle Unfallraten auf allen deutschen Bundesautobahnen darstellen lassen könnten.\n\nA38_gesamt &lt;- bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\nNun kommen wir zur grafischen Darstellung. Wir wollen im Hintergrund den Verlauf der A38 sehen, daher filtern wir uns aus dem Datensatz der Bundesautobahnen “bfstn” die Autobahn 38. Außerdem wollen wir uns drei Städte entlang der A38 für mehr Kontext darstellen. Dafür suchen wir uns die Koordinaten der Städte aus dem Internet. Diese sind allerdings in dem Koordinatenreferenzsystem 4326, daher transformieren (“st_transform”) wir sie in das CRS der anderen Daten (25832). In unserem ggplot stellen wir nun den Verlauf der A38 (“data = A38”) und die Städte (“data = staedte”) dar und beschriften die Städte mit “geom_sf_text()”. Und nun kommen endlich die Daten der Unfallraten. Diese filtern wir, dass nur Abschnitte mit Werten angezeigt werden (“filter(!is.na())”). Das machen wir erst hier und nicht schon eher, um die Zeilen nicht grundsätzlich aus dem Datensatz entfernen wollen, weil wir damit noch weiterrechnen. Für die Barrierefreiheit nutzen wir die Farbskala “scale_color_viridis_b” und beschriften unser Diagramm.\n\nA38 &lt;- bfstn |&gt; filter(Str_Kennung == \"A38\")\nstaedte &lt;- st_as_sf(\n  tibble::tribble(\n  ~stadt, ~lat, ~lon,\n  \"Leipzig\", 51.3402, 12.3601,\n  \"Nordhausen\", 51.5018, 10.7957,\n  \"Göttingen\", 51.5455, 9.9055,\n  ),\n  coords = c(\"lon\", \"lat\"),\n  crs = 4326\n) |&gt;\n  st_transform(25832)\n\nggplot () +\n  geom_sf(data = A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = staedte, color = \"red\") +\n  geom_sf_text(data = staedte, aes(label=stadt), nudge_y = 5000) +\n  geom_sf(\n    data = A38_gesamt |&gt; filter(!is.na(unfallrate)), \n    size = 2.5, \n    mapping = aes(color = unfallrate)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallrate\\n(Unfälle pro\\n1 Mio. Kfz-km)\") +\n  labs(title = \"Unfallraten nach Abschnitten der A38 im Jahr 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nWir sehen, dass viele Abschnitte eine Unfallrate von unter 0,12 Unfällen pro 1 Million Kfz-km aufweisen. Der (sehr schmale) Abschnitt bei Nordhausen zeigt hingegen eine Unfallrate von über 0,16 Unfällen pro 1 Million Kfz-km. Ein Blick in den Datensatz zeigt uns, dass dieser Abschnitt nur 585 Meter lang ist. Dadurch fallen einzelne Unfälle dort deutlich stärker ins Gewicht. Bei der Interpretation unserer Ergebnisse müssen wir daher stets unseren technischen Sachverstand einbringen und die Ergebnisse in den jeweiligen Kontext einordnen.\n\n\n\n3.2.2 Die Unfalldichte UD\n“Die [Unfalldichte] ist ein Maß für die (längenbezogene) Häufigkeit, mit der sich Unfälle während eines bestimmten Zeitraums auf einem bestimmten Straßenabschnitt ereignet haben” (FGSV (2003), S. 6). Dementsprechend lautet die Formel:\n\\[\nUD = \\frac{U}{L \\cdot t}\n\\]\nDa wir schon viel Vorarbeit geleistet haben, können wir zur Berechnung der Unfalldichte unserem Datensatz einfach eine weitere Spalte mit dem Namen “unfalldichte” und der Formel zur Berechnung der Unfalldichte hinzufügen.\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  mutate(unfalldichte = Unfaelle_2023 / (laenge_km * t1))                             \n\nAuch für die Unfalldichte schauen wir uns unsere ausgewählte Autobahn 38 an.\n\nA38_gesamt &lt;- bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\nDie grafische Darstellung übernehmen wir von der Unfallrate und tauschen nur die Variablen und die Beschriftungen aus. Jedoch ergänzen wir noch Grenzen bei der Beschriftung, da uns die Darstellung damit besser gefällt.\n\nggplot () +\n  geom_sf(data = A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = staedte, color = \"red\") +\n  geom_sf_text(data = staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = A38_gesamt |&gt; filter(!is.na(unfalldichte)), \n    size = 2.5, \n    mapping = aes(color = unfalldichte)\n    ) +\n  scale_color_viridis_b(direction = -1, limits = c(0, 10),  name = \"Unfalldichte\\n(Unfälle pro\\nkm und Jahr)\") +\n  labs(title = \"Unfalldichten nach Abschnitten der A38 im Jahr 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nIm Gegensatz zur Unfallrate sehen wir deutlich mehr farbige Abschnitte. Das liegt daran, dass die Unfalldichte unabhängig von der DTV ist und wir daher auch Abschnitte ohne Zählstellen darstellen können. Die große Mehrheit der Abschnitte hat eine Unfalldichte von unter 2,5 Unfällen pro Kilometer und Jahr. Wir sehen aber auch hier die Auswirkung von kurzen Abschnitten, diese haben tendenziell höhere Unfalldichten als längere Abschnitte.\n\n\n3.2.3 Die Unfallkostenrate UKR\n“Unfallkostenraten UKR beschreiben die entsprechenden durchschnittlichen volkswirtschaftlichen Kosten durch Straßenverkehrsunfälle, die bei einer Fahrleistung von 1000 Kfz-km in diesem Straßenabschnitt entstanden sind.” (FGSV (2003), S.5). Die Formel lautet entsprechend:\n\\[\nUKR = \\frac{1000 \\cdot UK}{365 \\cdot DTV \\cdot L \\cdot t}\n\\]\nDie Unfallkosten UK werden über einen Betrachtungszeitraum von drei Jahren berechnet. Je nachdem, welche Unfalldaten vorliegen, werden unterschiedliche Formeln angewandt. Da aus dem Unfallatlas nur Unfälle mit Personenschaden und keine mit Sachschäden zur Verfügung stehen, wird die folgende Formel verwendet:\n\\[\nUK = U(SP) * WU(SP) + U(LV) * WU(LV)\n\\]\nmit\n\nU(SP) : Unfälle mit schwerem Personenschaden (Schwerverletzte und Getötete)\nWU(SP) : Unfallkostensatz von Unfällen mit schwerem Personenschaden\nU(LV) : Unfälle mit leichtem Personenschaden\nWU(LV) : Unfallkostensatz von Unfällen mit leichtem Personenschaden\n\nDie Unfallkostensätze werden den Empfehlungen für die Sicherheitsanalyse von Straßennetzen (FGSV, 2003) entnommen.\n\n3.2.3.1 Schritt 1: Unfalldaten\nDa wir nun mit noch mehr Datensätzen arbeiten und die gleichen Veränderungen vornehmen, nutzen wir nun vermehrt “function”. So müssen wir nur einmal definieren, was wir machen wollen und können dann die function auf die verschiedenen Datensätze anwenden. Als erstes bereiten wir uns die Unfalldaten aus den Jahren 2022 und 2021 analog zu der Aufbereitung am Anfang mit dem Datensatz aus 2023 auf.\n\nread_one_file &lt;- function(file){\n  data &lt;- read_csv2(file)\n  sf::st_as_sf(data, coords = c(\"LINREFX\", \"LINREFY\"), crs = 25832) %&gt;%\n    st_zm()\n}\n\nunfaelle_2022 &lt;- read_one_file(\"data/Unfallorte2022_LinRef.csv\")\nunfaelle_2021 &lt;- read_one_file(\"data/Unfallorte2021_LinRef.csv\")\n\nWie auch bei den Unfalldaten aus 2023 fügen wir den Unfalldaten den nächstgelegenen Autobahnabschnitt und die Entfernung zu diesem hinzu und filtern nach allen Unfällen, die maximal 20 Meter von einem Autobahnabschnitt entfernt sind.\n\nnearest_autobahn &lt;- function(data) {\n  data |&gt;\n    mutate(\n      nearest_autobahn_id = st_nearest_feature(geometry, bfstn),\n      nearest_autobahn_distance = st_distance(geometry, bfstn[nearest_autobahn_id, ], by_element = TRUE),\n      nearest_autobahn_name = bfstn$Str_Kennung[nearest_autobahn_id]\n    ) |&gt;\n  filter(as.double(nearest_autobahn_distance) &lt;= 20) |&gt;\n  rename(abschnitt_id = nearest_autobahn_id) |&gt;\n  select(UKATEGORIE, nearest_autobahn_name, abschnitt_id)\n}\n\nunfaelle_bab_2022 &lt;- nearest_autobahn(unfaelle_2022)\nunfaelle_bab_2021 &lt;- nearest_autobahn(unfaelle_2021)\n\nEbenfalls wie bei den Unfalldaten aus 2023 fassen wir die Unfalldaten je Abschnitt zusammen. Da wir gleich für die Unfallkosten aber auch die Unfallkategorie berücksichtigen werden, gruppieren wir nicht nur nach Abschnitten, sondern auch nach den Unfallkategorien.\n\nabschnitte &lt;- function(data) {\n  data |&gt;\n   st_set_geometry(NULL) |&gt;\n    group_by(abschnitt_id, UKATEGORIE) |&gt;\n    summarise(\n      Unfaelle = n(),\n      .groups = \"drop\"\n  ) \n}\n\nunfaelle_abschnitt_2023 &lt;- abschnitte(unfaelle_bab_2023)\nunfaelle_abschnitt_2022 &lt;- abschnitte(unfaelle_bab_2022)\nunfaelle_abschnitt_2021 &lt;- abschnitte(unfaelle_bab_2021)\n\nAls nächsten fügen wir alle drei Unfalldatensätze mit “bind_rows()” zu einem großen Unfalldatensatz zusammen.\n\nunfaelle_alle &lt;- bind_rows(unfaelle_abschnitt_2023, unfaelle_abschnitt_2022, unfaelle_abschnitt_2021)\n\nNun wollen wir wissen, wie viele schwere und leichte Unfälle es je Abschnitt gibt. Schwere Unfälle sind Unfälle mit Schwerverletzten (Kategorie 2) und Getöteten (Kategorie 1). Leichte Unfälle sind die Unfallkategorie 3. Dazu filtern wir nach der oder den jeweiligen Kategorie, gruppieren nach Abschnitten und summieren die Unfallzahlen.\n\nunfaelle_sp_3j &lt;- unfaelle_alle |&gt;\n  filter(UKATEGORIE %in% c(1, 2)) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    unfaelle_sp_summe_3j = sum(Unfaelle, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nunfaelle_lv_3j &lt;- unfaelle_alle |&gt;\n  filter(UKATEGORIE == 3) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    unfaelle_lv_summe_3j = sum(Unfaelle, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nDiese beiden neuen Datensätze fügen wir als Spalten zu einem gemeinsamen Datensatz zusammen. Dabei ergänzen wir noch, dass wenn es keine Unfälle gibt, nicht “NA” in der Zelle steht, sondern 0, da das hier im Sachzusammenhang sinnvoll ist und wir dann später besser damit rechnen können.\n\nunfaelle_gesamt &lt;- unfaelle_sp_3j |&gt;\n  full_join(unfaelle_lv_3j, by = \"abschnitt_id\") |&gt;\n  mutate(\n    unfaelle_sp_summe_3j = replace_na(unfaelle_sp_summe_3j, 0),\n    unfaelle_lv_summe_3j = replace_na(unfaelle_lv_summe_3j, 0)\n  )\n\nDie Unfalldaten nach Abschnitten aus den drei beobachteten Jahren fügen wir nun dem großen Datensatz hinzu.\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  mutate(abschnitt_id = row_number()) |&gt;\n  left_join(unfaelle_gesamt, by = \"abschnitt_id\") |&gt;\n  select(Str_Kennung, laenge_km, DTV_2023, Unfaelle_2023, abschnitt_id, laenge_km, unfallrate, unfalldichte, unfaelle_sp_summe_3j, unfaelle_lv_summe_3j)\n\n\n\n3.2.3.2 Schritt 2: Dauerzählstellen\nAuch für die Dauerzählstellen nutzen wir “function”, um uns Arbeit zu sparen. Wie für die Dauerzählstellen aus 2023 lesen wir die neuen Datensätze ein und achten auf die richtige Encodierung.\n\nread_dzs_file &lt;- function(file) {\n  read_csv2(file, locale = locale(encoding = 'iso-8859-1'))\n}\n\ndzs_2022 &lt;- read_dzs_file(\"data/Jawe2022.csv\")\ndzs_2021 &lt;- read_dzs_file(\"data/Jawe2021.csv\")\n\nAuch im nächsten Schritt gehen wir wie am Anfang vor, filtern nach Zählstellen auf Autobahnen, ignorieren Zählstellen ohne Zähldaten, achten auf das richtige CRS und fügen eine Spalte zum nächstgelegenen Autobahnabschnitt hinzu.\n\nfilter_dzs &lt;- function(data) {\n  data |&gt;\n    filter(Str_Kl == \"A\") |&gt;\n    drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n    st_as_sf(coords =  c(\"Koor_UTM32_E\", \"Koor_UTM32_N\"),  crs = 25832) |&gt;\n    mutate(abschnitt_id = st_nearest_feature(geometry, bfstn))\n}\n\ndzs_2022 &lt;- filter_dzs(dzs_2022)\ndzs_2021 &lt;- filter_dzs(dzs_2021)\n\nNun fassen wir die DTV-Daten auf Abschnittsebene zusammen und bilden Mittelwerte der DTV.\n\ndzs_abschnitt &lt;- function(data){\n  data |&gt;\n  st_set_geometry(NULL) |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(DTV = mean(DTV_Kfz_MobisSo_Q, na.rm = TRUE))\n}\n\ndzs_abschnitt_2022 &lt;- dzs_abschnitt(dzs_2022)\ndzs_abschnitt_2021 &lt;- dzs_abschnitt(dzs_2021)\n\nAls nächsten fügen wir alle drei Datensätze zu einem großen zusammen.\n\ndzs_alle &lt;- bind_rows(dzs_abschnitt_2023, dzs_abschnitt_2022, dzs_abschnitt_2021)\n\nIm Gegensatz zu den Unfalldaten, die aufsummiert werden, wird methodisch bei der durchschnittlichen täglichen Verkehrsstärke der Mittelwert je Abschnitt gebildet.\n\ndzs_gesamt &lt;- dzs_alle |&gt;\n  group_by(abschnitt_id) |&gt;\n  summarise(\n    dtv_mittelwert_3j = round(mean(DTV, na.rm = TRUE)),\n    .groups = \"drop\"\n  )\n\nNun können wir die DTV-Daten dem Datensatz des Bundesfernstraßennetzes hinzufügen.\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  left_join(dzs_gesamt, by = \"abschnitt_id\")\n\n\n\n3.2.3.3 Schritt 3: Unfallkostensätze definieren\nDie Unfallkostensätze werden nach den ESN (FGSV, 2003) definiert. Dabei wird für die schweren Personenunfälle der Mittelwert aus den Bundesländern Sachsen, Sachsen-Anhalt, Thüringen, Niedersachsen gebildet, da die A38 durch diese vier Bundesländer verläuft. Die Länge je Bundesland wird hierbei außer Acht gelassen.\n\nWU_SP_bab = 325000\nWU_LV_bab = 31000\nt2 = 3\n\n\n\n3.2.3.4 Schritt 4: Unfallkostenraten berechnen\nWie bei der Unfallrate und -dichte fügen wir nun eine Spalte zur Unfallkostenrate dem großen Datensatz hinzu. Dafür nutzen wir einen Zwischenschritt und erstellen uns erst noch eine Spalte zu den Unfallkosten.\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  mutate(\n    unfallkosten = unfaelle_sp_summe_3j * WU_SP_bab + unfaelle_lv_summe_3j * WU_LV_bab ,\n    unfallkostenrate = (1000*unfallkosten)/(365*dtv_mittelwert_3j*laenge_km*t2)\n  )\n\n\n\n3.2.3.5 Schritt 5: Ausgewählte Autobahn\n\nA38_gesamt &lt;- bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\n\n\n3.2.3.6 Schritt 6: Grafische Darstellung\n\nggplot () +\n  geom_sf(data = A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = staedte, color = \"red\") +\n  geom_sf_text(data = staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = A38_gesamt |&gt; filter(!is.na(unfallkostenrate)), \n    size = 2.5, \n    mapping = aes(color = unfallkostenrate)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallkostenrate\\n(Euro pro\\n1000 Kfz und km und Jahr)\") +\n  labs(title = \"Unfallkostenraten nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nWir sehen, dass viele Abschnitte eine Unfallkostenrate von unter 15 Euro pro 1000 Kfz und km und Jahr haben. Auffällig ist ein Abschnitt zwischen Nordhausen und Göttigen. Ein Blick in den Datensatz verrät, dass es hier innerhalb der drei beobachteten Jahre 10 schwere und 4 leichte Unfälle auf etwa 6,5 km Länge und bei etwa 22.000 Kfz pro Tag gab.\n\n\n\n3.2.4 Unfallkostendichte UKD\nDie Unfallkostendichte UKD beschreibt “die mittleren volkswirtschaftlichen Kosten durch Straßenverkehrsunfälle, die auf 1 km Länge des Straßenabschnittes entfallen” (FGSV (2003), S. 6).\nDie Formel lautet:\n\\[\nUKD = \\frac{UK}{1000 \\cdot L \\cdot t}\n\\]\nDa die Unfallkosten bereits berechnet sind, ist die Berechnung der Unfallkostendichte nun schneller.\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  mutate(unfallkostendichte = unfallkosten/(1000*laenge_km*t2))\n\n\nA38_gesamt &lt;- bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\n\nggplot () +\n  geom_sf(data = A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = staedte, color = \"red\") +\n  geom_sf_text(data = staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = A38_gesamt |&gt; filter(!is.na(unfallkostendichte)), \n    size = 2.5, \n    mapping = aes(color = unfallkostendichte)\n    ) +\n  scale_color_viridis_b(direction = -1, name = \"Unfallkostendichte\\n(1000 Euro pro\\nkm und Jahr)\") +\n  labs(title = \"Unfallkostendichten nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\n3.2.5 Sicherheitspotenzial SIPO\n“Das Sicherheitspotenzial SIPO eines Straßenabschnittes ist definiert als Unterschied zwischen den Unfallkosten (Anzahl und Schwere der Unfälle), die bei richtliniengerechtem Ausbau zu erwarten wären, und den vorhandenen Unfallkosten. […] Kenngröße für das Sicherheitspotenzial SIPO ist die Differenz zwischen der vorhandenen Unfallkostendichte UKD eines Netzabschnittes im Betrachtungszeitraum und der Grundunfallkostendichte gUKD.” (FGSV (2003), S. 8f.)\n\\[\nSIPO = UKD - gUKD\n\\]\nDie Grundunfallkostendichte gUKD wird mit der folgenden Formel berechnet:\n\\[\ngUKD = \\frac{gUKR \\cdot DTV \\cdot 365}{10^6}\n\\]\nmit der Grundunfallkostenrate gUKR, die den ESN (FGSV, 2003) zu entnehmen ist.\n\ngUKR_bab = 11\n\n\nbfstn_gesamt &lt;- bfstn_gesamt |&gt;\n  mutate(\n    gUKD = (gUKR_bab * dtv_mittelwert_3j * 365)/10^6,\n    sicherheitspotenzial = unfallkostendichte - gUKD\n)\n\n\nA38_gesamt  &lt;- bfstn_gesamt |&gt;\n  filter(Str_Kennung == \"A38\")\n\n\nggplot () +\n  geom_sf(data = A38, colour = \"grey\", size = 0.4) +\n  geom_sf(data = staedte, color = \"red\") +\n  geom_sf_text(data = staedte, aes(label=stadt), nudge_y = 5000) +\n    geom_sf(\n    data = A38_gesamt |&gt; filter(!is.na(sicherheitspotenzial)), \n    size = 2.5, \n    mapping = aes(color = sicherheitspotenzial)\n    ) +\n  scale_color_viridis_b(direction = -1, breaks = c(0, 50, 100), name = \"Sicherheitspotenzial\\n(1000 Euro pro\\nkm und Jahr)\") +\n  labs(title = \"Sicherheitspotenziale nach Abschnitten der A38 in den Jahren 2021 - 2023\") +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 10, face = \"bold\", hjust = 0.5),\n    axis.title = element_blank(),\n    axis.text  = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n\n\n\n\n\n\n\nEin Sicherheitspotenziel, dass kleiner gleich 0 ist, bedeutet, dass die Unfallkostendichte geringer als oder gleich der Grundunfallkostendichte ist. Das heißt, dass hier weniger (schwere) Unfälle aufgetreten sind, als aufgrund des Ausbaus zu erwarten wären. Das ist also etwas positives, hier gibt es (zumindest für den beobachteten Zeitraum) wenig Handlungsdruck. Je größer das Sicherheitspotenzial ist, desto mehr Bedarf besteht, die Infrastruktur sicherer zu gestalten. In unserer Grafik ist das vor allem der Abschnitt zwischen Nordhausen und Göttingen, der schon bei der Unfallkostenrate auffällig war.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Musterlösung mit Erläuterungen</span>"
    ]
  },
  {
    "objectID": "aufgabenstellung.html",
    "href": "aufgabenstellung.html",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "",
    "text": "1.1 Datenquellen\nDie statistischen Ämter des Bundes und der Länder erheben und veröffentlichen mit der Straßenverkehrsunfallstatistik die Verkehrsunfälle mit Personenschaden oder Sachschaden in Deutschland. Im Unfallatlas werden Unfälle mit Personenschaden geführt. Für die Sicherheitsanalyse von Verkehrsnetzen können diese Daten verwendet und analysiert werden.\nVerwenden Sie für das Straßennetz die Daten des Bundesinformationssystems Straße (BISStra) der Bundesanstalt für Straßen- und Verkehrswesen (BASt), Stichwortsuche “Bundesfernstraßennetz”.\nDie durchschnittliche Verkehrsstärke (DTV) auf Autobahnen kann ebenfalls über die BASt unter dem Stichwort “Dauerzählstellen” bezogen werden.\nDie Formeln der Kenngrößen für die Sicherheitsbewertung werden den Empfehlungen für die Sicherheitsanalyse von Straßennetzen (ESN) (2003) der Forschungsgesellschaft für Straßen- und Verkehrswesen (FGSV) entnommen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabenstellung.html#aufgabe-1-anzahl-der-verkehrsunfälle",
    "href": "aufgabenstellung.html#aufgabe-1-anzahl-der-verkehrsunfälle",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "1.2 Aufgabe 1 : Anzahl der Verkehrsunfälle",
    "text": "1.2 Aufgabe 1 : Anzahl der Verkehrsunfälle\nErstellen Sie eine tabellarische Übersicht der Unfallzahlen nach Unfallkategorie für eine ausgewählte Autobahn und für Gesamtdeutschland in einem frei wählbaren Jahr.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabenstellung.html#aufgabe-2-unfallkenngrößen-auf-autobahnen",
    "href": "aufgabenstellung.html#aufgabe-2-unfallkenngrößen-auf-autobahnen",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "1.3 Aufgabe 2 : Unfallkenngrößen auf Autobahnen",
    "text": "1.3 Aufgabe 2 : Unfallkenngrößen auf Autobahnen\nStellen Sie die folgende Unfallkenngrößen für eine ausgewählte Autobahn in einem frei wählbaren Jahr grafisch dar:\n\ndie Unfallrate UR,\ndie Unfalldichte UD,\ndie Unfallkostenrate UKR,\ndie Unfallkostendichte UKD und\ndas Sicherheitspotential SIPO",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  },
  {
    "objectID": "aufgabenstellung.html#datenquellen",
    "href": "aufgabenstellung.html#datenquellen",
    "title": "1  Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen",
    "section": "",
    "text": "Übungsaufgabe 1.1 Anzahl der Verkehrsunfälle\nErstellen Sie eine tabellarische Übersicht der Unfallzahlen nach Unfallkategorie für eine ausgewählte Autobahn und für Gesamtdeutschland in einem frei wählbaren Jahr.\n\n\nÜbungsaufgabe 1.2 Unfallkenngrößen auf Autobahnen\nStellen Sie die folgende Unfallkenngrößen für eine ausgewählte Autobahn in einem frei wählbaren Jahr grafisch dar:\n\ndie Unfallrate UR,\ndie Unfalldichte UD,\ndie Unfallkostenrate UKR,\ndie Unfallkostendichte UKD und\ndas Sicherheitspotential SIPO",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span>"
    ]
  }
]