<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Musterlösung mit Erläuterungen – Anwendungsbaustein Sicherheitsanalyse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./musterloesung.html" rel="prev">
<link href="./bilder/favicon_bcd_new.svg" rel="icon" type="image/svg+xml">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-70a47bd5681a7291082a5b9f83d58762.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./sicherheitsanalyse.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Musterlösung mit Erläuterungen</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./bilder/logo_bcd_new.svg" alt="" class="sidebar-logo light-content py-0 d-lg-inline d-none">
      <img src="./bilder/logo_bcd_new.svg" alt="" class="sidebar-logo dark-content py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Anwendungsbaustein Sicherheitsanalyse</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/bausteine-der-datenanalyse/a-sicherheitsanalyse" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Einleitung</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./aufgabe/aufgaben_sicherheitsanalyse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Aufgaben zur Sicherheitsanalyse von Verkehrsnetzen</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./musterloesung.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Musterlösung Sicherheitsanalyse</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sicherheitsanalyse.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Musterlösung mit Erläuterungen</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#aufgabe-1-anzahl-der-verkehrsunfälle" id="toc-aufgabe-1-anzahl-der-verkehrsunfälle" class="nav-link active" data-scroll-target="#aufgabe-1-anzahl-der-verkehrsunfälle"><span class="header-section-number">3.1</span> Aufgabe 1 : Anzahl der Verkehrsunfälle</a></li>
  <li><a href="#aufgabe-2-unfallkenngrößen-auf-autobahnen" id="toc-aufgabe-2-unfallkenngrößen-auf-autobahnen" class="nav-link" data-scroll-target="#aufgabe-2-unfallkenngrößen-auf-autobahnen"><span class="header-section-number">3.2</span> Aufgabe 2 : Unfallkenngrößen auf Autobahnen</a>
  <ul>
  <li><a href="#die-unfallrate-ur" id="toc-die-unfallrate-ur" class="nav-link" data-scroll-target="#die-unfallrate-ur"><span class="header-section-number">3.2.1</span> Die Unfallrate UR</a>
  <ul class="collapse">
  <li><a href="#verbinden-der-datensätze-des-bundesfernstraßennetzes-mit-den-zählstellen-und-den-unfällen" id="toc-verbinden-der-datensätze-des-bundesfernstraßennetzes-mit-den-zählstellen-und-den-unfällen" class="nav-link" data-scroll-target="#verbinden-der-datensätze-des-bundesfernstraßennetzes-mit-den-zählstellen-und-den-unfällen"><span class="header-section-number">3.2.1.1</span> Verbinden der Datensätze des Bundesfernstraßennetzes mit den Zählstellen und den Unfällen</a></li>
  <li><a href="#unfallraten-berechnen" id="toc-unfallraten-berechnen" class="nav-link" data-scroll-target="#unfallraten-berechnen"><span class="header-section-number">3.2.1.2</span> Unfallraten berechnen</a></li>
  <li><a href="#unfallraten-auf-der-a38" id="toc-unfallraten-auf-der-a38" class="nav-link" data-scroll-target="#unfallraten-auf-der-a38"><span class="header-section-number">3.2.1.3</span> Unfallraten auf der A38</a></li>
  </ul></li>
  <li><a href="#die-unfalldichte-ud" id="toc-die-unfalldichte-ud" class="nav-link" data-scroll-target="#die-unfalldichte-ud"><span class="header-section-number">3.2.2</span> Die Unfalldichte UD</a></li>
  <li><a href="#die-unfallkostenrate-ukr" id="toc-die-unfallkostenrate-ukr" class="nav-link" data-scroll-target="#die-unfallkostenrate-ukr"><span class="header-section-number">3.2.3</span> Die Unfallkostenrate UKR</a>
  <ul class="collapse">
  <li><a href="#schritt-1-unfalldaten" id="toc-schritt-1-unfalldaten" class="nav-link" data-scroll-target="#schritt-1-unfalldaten"><span class="header-section-number">3.2.3.1</span> Schritt 1: Unfalldaten</a></li>
  <li><a href="#schritt-2-dauerzählstellen" id="toc-schritt-2-dauerzählstellen" class="nav-link" data-scroll-target="#schritt-2-dauerzählstellen"><span class="header-section-number">3.2.3.2</span> Schritt 2: Dauerzählstellen</a></li>
  <li><a href="#schritt-3-unfallkostensätze-definieren" id="toc-schritt-3-unfallkostensätze-definieren" class="nav-link" data-scroll-target="#schritt-3-unfallkostensätze-definieren"><span class="header-section-number">3.2.3.3</span> Schritt 3: Unfallkostensätze definieren</a></li>
  <li><a href="#schritt-4-unfallkostenraten-berechnen" id="toc-schritt-4-unfallkostenraten-berechnen" class="nav-link" data-scroll-target="#schritt-4-unfallkostenraten-berechnen"><span class="header-section-number">3.2.3.4</span> Schritt 4: Unfallkostenraten berechnen</a></li>
  <li><a href="#schritt-5-ausgewählte-autobahn" id="toc-schritt-5-ausgewählte-autobahn" class="nav-link" data-scroll-target="#schritt-5-ausgewählte-autobahn"><span class="header-section-number">3.2.3.5</span> Schritt 5: Ausgewählte Autobahn</a></li>
  <li><a href="#schritt-6-grafische-darstellung" id="toc-schritt-6-grafische-darstellung" class="nav-link" data-scroll-target="#schritt-6-grafische-darstellung"><span class="header-section-number">3.2.3.6</span> Schritt 6: Grafische Darstellung</a></li>
  </ul></li>
  <li><a href="#unfallkostendichte-ukd" id="toc-unfallkostendichte-ukd" class="nav-link" data-scroll-target="#unfallkostendichte-ukd"><span class="header-section-number">3.2.4</span> Unfallkostendichte UKD</a></li>
  <li><a href="#sicherheitspotenzial-sipo" id="toc-sicherheitspotenzial-sipo" class="nav-link" data-scroll-target="#sicherheitspotenzial-sipo"><span class="header-section-number">3.2.5</span> Sicherheitspotenzial SIPO</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/bausteine-der-datenanalyse/a-sicherheitsanalyse/blob/main/sicherheitsanalyse.qmd" class="toc-action"><i class="bi bi-github"></i>Quellcode anzeigen</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Musterlösung mit Erläuterungen</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="aufgabe-1-anzahl-der-verkehrsunfälle" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="aufgabe-1-anzahl-der-verkehrsunfälle"><span class="header-section-number">3.1</span> Aufgabe 1 : Anzahl der Verkehrsunfälle</h2>
<p>Als frei wählbare Jahr wird 2023 gewählt und als frei wählbare Autobahn die A38.</p>
<p>Als erstes werden die Daten vom Unfallatlas heruntergeladen und in R geladen. Danach wird der Datensatz in ein räumliches Punktobjekt umgewandelt. Die Koordinaten stammen aus den Spalten “LINREFX” und “LINREFY”. Mit CRS (Coordinate Reference System) wird das Koordinatenreferenzsystem EPSG:25832 definiert. Falls sich in den geometrischen Daten noch Informationen zur Höhe (z-Dimension) oder Messwerte oder Attribute (m-Dimension) enthalten sind, werden diese nun entfernt, damit wir gleich sauber mit ihnen weiterrechnen können.</p>
<p>Als nächstes wird das Straßennetz der Bundesfernstraßen als Datensatz ins Projekt geladen. Diese Daten bekommen wir von der Bundesanstalt für Straßen- und Verkehrswesen (BASt). Das Bundesfernstraßennetz beinhaltet Daten zu Bundesautobahnen und Bundesstraßen. Da für uns nur die Autobahnen relevant sind, filtern wir nur diese heraus. Wir wählen als Achse die Bestandsachse, da dies die mittlere Achse der Straße ist und wir keine Unterscheidung der Fahrtrichtung vornehmen müssen. Falls sich in den geometrischen Daten noch Informationen zur Höhe (z-Dimension) oder Messwerte oder Attribute (m-Dimension) enthalten sind, werden diese nun entfernt, damit wir gleich sauber mit ihnen weiterrechnen können.</p>
<p>Den Unfalldaten soll nun aufgrund ihrer Lage in Deutschland der nächstgelegene Autobahnabschnitt und die Entfernung zu diesem hinzugefügt werden. “st_nearest_feature” gibt dabei die Zeilennummer des nächstgelegenen Autobahnabschnitts im Datensatz “bfstn” wieder. Außerdem suchen wir mit “bfstn$Str_Kennung[abschnitt_id]” aus dem Datensatz “bfstn” und der Spalte “Str_Kennung” genau den Eintrag, dessen Zeile durch “abschnitt_id” angegeben wird. Damit bekommen wir statt einer Nummer eines Autobahnabschnittes den Namen der Autobahn (z.B. A1). Zudem wollen wir nur Unfälle, die auf Autobahnen passiert sind, berücksichtigen. Dafür filtern wir nach Unfällen, die in einem 20 m Umkreis zur Bestandsachse der Autobahnen sind. Die 20 m wählen wir, um fast alle Unfälle auf den Fahrbahnen, auch bei 6- oder 8-spurigen Autobahnen, einzuschließen und fast alle Unfälle daneben auszuschließen. Es gibt uns aber keine Garantie, dass alle Unfälle, die wir nun filtern, tatsächlich auf Autobahnen liegen. Den Unterschied des Filters sehen wir im Environment: Der Unfalldatensatz aus 2023 beinhaltet 269.048 Unfälle insgesamt, der Unfalldatensatz für Autobahnen nur noch 22.114. Für mehr Übersichtlichkeit vereinfachen wir unseren Datensatz und lassen uns mit “select” nur bestimmte Spalten anzeigen.</p>
<p>Für die tabellarische Übersicht der Unfälle erstellen wir einen neuen Datensatz, der nur Unfälle auf der Autobahn 38 beinhaltet.</p>
<p>Nun folgt die tabellarische Darstellung. Sowohl für alle Unfälle auf deutschen Autobahnen als auch auf der A38 führen wir folgende Schritte durch: Mit “st_set_geometry(NULL)” entfernen wir die Geometriespalte, da für die Auswertung in Tabellenform nur die Attributdaten benötigt werden. Anschließend gruppieren wir die Unfalldaten nach ihrer Kategorie und berechnen mit “summarise” die Anzahl der Unfälle je Unfallkategorie. Um eine weitere Zeile mit den Summen hinzufügen zu können, muss die Spalte zur Unfallkategorie in einen Zeichenvektor umgewandelt werden (“mutate(UKATEGORIE = as.character(UKATEGORIE))”). Die neue Zeile hängen wir mit “bind_rows()” an. Diese letzte Zeile der Spalte UKATEGORIE („Summe“) enthält nun die Gesamtanzahl aller Unfälle über alle Kategorien hinweg und dient als übersichtliche Gesamtsumme in der Ergebnistabelle. Nun fügen wir die beiden einzelnen Tabellen noch zu einer Tabelle zusammen mit “left_join()” und benennen die Zeilennamen um. Mit “kable()” stellen wir die Tabelle dar und können ihr noch eine Überschrift hinzufügen.</p>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Anzahl der Verkehrsunfälle nach Unfallkategorie (A38 und alle deutschen Autobahnen) im Jahr 2023</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Unfallkategorie</th>
<th style="text-align: right;">A38</th>
<th style="text-align: right;">Autobahnen</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Unfall mit Getöteten</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">282</td>
</tr>
<tr class="even">
<td style="text-align: left;">Unfall mit Schwerverletzten</td>
<td style="text-align: right;">43</td>
<td style="text-align: right;">3739</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Unfall mit Leichtverletzten</td>
<td style="text-align: right;">132</td>
<td style="text-align: right;">18093</td>
</tr>
<tr class="even">
<td style="text-align: left;">Summe</td>
<td style="text-align: right;">183</td>
<td style="text-align: right;">22114</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section id="aufgabe-2-unfallkenngrößen-auf-autobahnen" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="aufgabe-2-unfallkenngrößen-auf-autobahnen"><span class="header-section-number">3.2</span> Aufgabe 2 : Unfallkenngrößen auf Autobahnen</h2>
<section id="die-unfallrate-ur" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="die-unfallrate-ur"><span class="header-section-number">3.2.1</span> Die Unfallrate UR</h3>
<p>“Die Unfallrate ist ein Maß für das (fahrleistungsbezogene) Risiko des Verkehrsteilnehmers, in einen Unfall verwickelt zu werden oder dabei zu verunglücken.” (ESN, 2003, S. 5) Die Formel lautet <span class="math display">\[
UR = \frac{U \cdot 10^6}{DTV \cdot L \cdot 365 \cdot t}
\]</span> mit den Kenngrößen</p>
<ul>
<li><strong>U</strong>: Anzahl der Unfälle</li>
<li><strong>DTV</strong> : durchschnittliche tägliche Verkehrsstärke in Kraftfahrzeugen pro 24 Stunden [Kfz/24h oder Kfz/d]</li>
<li><strong>L</strong> : untersuchte Streckenlänge [km]</li>
<li><strong>t</strong> : untersuchter Zeitraum [a].</li>
</ul>
<p>Die DTV kann den Dauerzählstellen der BASt entnommen werden. Die Streckenlänge ist im Datensatz des Bundesfernstraßennetzes bereits enthalten.</p>
<p>Als erstes laden wir die Daten der Dauerzählstellen in unser Projekt. Mit dem Argument “locale(encoding =”iso-8859-1”)” stellen wir sicher, dass Umlaute und Sonderzeichen, die in deutschsprachigen Datensätzen häufig vorkommen, korrekt eingelesen werden. Da wir die Dauerzählstellen später mit dem Bundesfernstraßennetz verknüpfen möchten, berücksichtigen wir wie bei den anderen Datensätzen ausschließlich Autobahnen. Dazu filtern wir nach der Straßenklasse “Str_Kl ==”A”“. Anschließend entfernen wir mit”drop_na(DTV_Kfz_MobisSo_Q)” alle Beobachtungen, für die keine Verkehrsstärkewerte vorliegen, sodass nur vollständige und auswertbare Zählstellen verbleiben. Im nächsten Schritt wird der Datensatz in ein sf-Objekt umgewandelt. Aus den Koordinatenspalten “Koor_UTM32_E” und “Koor_UTM32_N” werden Punktgeometrien mit dem gleichen Koordinatensystem wie bei den anderen Datensätzen erzeugt. Dadurch sind spätere räumliche Operationen kompatibel. Wie auch bei den anderen räumlichen Datensätzen entfernen wir anschließend mögliche z- und m-Dimensionen aus den Geometrien. Dies stellt sicher, dass alle Geometrien zweidimensional sind und problemlos in weiteren räumlichen Analysen verwendet werden können. Im nächsten Schritt werden die Dauerzählstellen wie bei den Unfällen den nächstgelegenen Autobahnabschnitten des Bundesfernstraßennetzes zugeordnet. Mit “st_nearest_feature()” wird für jede Zählstelle der Index des nächstgelegenen Abschnitts ermittelt und als “abschnitt_id” gespeichert. Im Gegensatz zu den Unfalldaten müssen wir keine Entfernung zur Autobahn ermitteln, weil wir wissen, dass die Zählstellen tatsächlich an Autobahnen sind.</p>
<p>Bevor wir mit den Daten der Dauerzählstellen weiterrechnen, prüfen wir, ob jedem Autobahnabschnitt maximal eine Dauerzählstelle zugeordnet ist. In unserem Verständnis ist ein Autobahnabschnitt u.a. dadurch klassifiziert, dass in diesem keine Auffahrt oder Abfahrt vorhanden ist, daher würden zwei Zählstellen hier nur redudante DTV-Werte liefern. Bevor wir mit dieser Annahme weiterrechnen, kontrollieren wir sie.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 3
# Groups:   abschnitt_id [1]
  abschnitt_id DZ_Nr DTV_Kfz_MobisSo_Q
         &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;
1        14490 6730              28566
2        14490 6831              45945</code></pre>
</div>
</div>
<p>Wir sehen, dass unsere Annahme falsch ist und es tatsächlich einen Abschnitt mit zwei Zählstellen gibt und beide auch tatsächlich unterschiedliches Verkehrsaufkommen gibt. Zwischen den Zählstellen scheint es also auch die Möglichkeit zu geben, auf die Autobahn auf- oder von ihr abzufahren. Daher fassen wir die Verkehrsstärken nun auf Abschnittsebene zusammen. Hierzu wird die Geometrie entfernt und wir berechnen den mittlere DTV-Wert von beiden Zählstellen je Abschnitt. Und auch bei diesem Datensatz reduzieren wir die Anzahl der Spalten für mehr Übersichtlichkeit.</p>
<section id="verbinden-der-datensätze-des-bundesfernstraßennetzes-mit-den-zählstellen-und-den-unfällen" class="level4" data-number="3.2.1.1">
<h4 data-number="3.2.1.1" class="anchored" data-anchor-id="verbinden-der-datensätze-des-bundesfernstraßennetzes-mit-den-zählstellen-und-den-unfällen"><span class="header-section-number">3.2.1.1</span> Verbinden der Datensätze des Bundesfernstraßennetzes mit den Zählstellen und den Unfällen</h4>
<p>Bisher haben wir allen Unfällen den nächstgelegenen Autobahnabschnitt und die Entfernung zu diesem zugewiesen. Nun wollen wir wissen, wie viele Unfälle es pro Abschnitt gibt. Das machen wir mit “group_by()” und “summarise()”. Außerdem benennen wir die Spalte “nearest_autobahn_id” mit “rename()” in “abschnitt_id” um, damit wir die Datensätze gleich sauber verknüpfen können.</p>
<p>Nun können wir alle drei Datensätze (Bundesfernstraßennetz der Autobahnen, (mittlere) DTV an Dauerzählstellen und Summe von Unfällen je Abschnitt) zu einem Datensatz zusammenfügen. Das machen wir mit “left_join()”.</p>
</section>
<section id="unfallraten-berechnen" class="level4" data-number="3.2.1.2">
<h4 data-number="3.2.1.2" class="anchored" data-anchor-id="unfallraten-berechnen"><span class="header-section-number">3.2.1.2</span> Unfallraten berechnen</h4>
<p>Als erstes legen wir unseren Zeitraum “t1” als 1 (Jahr) fest.</p>
<p>Anschließend fügen wir dem Datensatz mit “mutate()” eine weitere Spalte mit dem Namen “unfallrate” hinzu, deren Werte mit der Formel für die Unfallrate berechnet werden. Außerdem filtern wir nur nach allen Zeilen, für die es auch eine Unfallrate gibt (“!is.na”).</p>
</section>
<section id="unfallraten-auf-der-a38" class="level4" data-number="3.2.1.3">
<h4 data-number="3.2.1.3" class="anchored" data-anchor-id="unfallraten-auf-der-a38"><span class="header-section-number">3.2.1.3</span> Unfallraten auf der A38</h4>
<p>Für unsere gewählte Autobahn 38 erstellen wir einen neuen Datensatz. Das erst so spät zu machen, ermöglicht uns, dass wir bei Bedarf recht einfach (z.B. mit Suchen und Ersetzen) unsere Auswahl verändern könnten oder uns auch alle Unfallraten auf allen deutschen Bundesautobahnen darstellen lassen könnten.</p>
<p>Nun kommen wir zur grafischen Darstellung. Wir wollen im Hintergrund den Verlauf der A38 sehen, daher filtern wir uns aus dem Datensatz der Bundesautobahnen “bab” die Autobahn 38 und legen als Farbe grau und die Breite der Linie 0.4 fest. Für die Barrierefreiheit nutzen wir die Farbskala “scale_color_viridis_b” (to-do)</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sicherheitsanalyse_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>To-Do BEschreibung Wir sehen, dass viele Abschnitte eine Unfallrate von unter 0,08 Unfällen pro 1 Million Kfz-km aufweisen. Der Abschnitt bei Nordhausen zeigt hingegen eine Unfallrate von über 0,16 Unfällen pro 1 Million Kfz-km. Ein Blick in den Datensatz zeigt jedoch, dass dieser Abschnitt nur 585 Meter lang ist. Dadurch fallen einzelne Unfälle dort deutlich stärker ins Gewicht. Bei der Interpretation unserer Ergebnisse müssen wir daher stets technischen Sachverstand einbringen und die Ergebnisse in den jeweiligen Kontext einordnen.</p>
</section>
</section>
<section id="die-unfalldichte-ud" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="die-unfalldichte-ud"><span class="header-section-number">3.2.2</span> Die Unfalldichte UD</h3>
<p>“Die [Unfalldichte] ist ein Maß für die (längenbezogene) Häufigkeit, mit der sich Unfälle während eines bestimmten Zeitraums auf einem bestimmten Straßenabschnitt ereignet haben” (ESN, 2003, S. 6). Dementsprechend lautet die Formel:</p>
<p><span class="math display">\[
UD = \frac{U}{L \cdot t}
\]</span></p>
<p>Da wir schon viel Vorarbeit geleistet haben, können wir zur Berechnung der Unfalldichte unserem Datensatz einfach eine weitere Spalte mit dem Namen “unfalldichte” und der Formel zur Berechnung der Unfalldichte hinzufügen.</p>
<p>Auch für die Unfalldichte schauen wir uns unsere ausgewählte Autobahn 38 an.</p>
<p>Grafische Darstellung: TO-DO</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sicherheitsanalyse_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>TO-DO: Beschreibung Grafik</p>
</section>
<section id="die-unfallkostenrate-ukr" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="die-unfallkostenrate-ukr"><span class="header-section-number">3.2.3</span> Die Unfallkostenrate UKR</h3>
<p>“Unfallkostenraten UKR beschreiben die entsprechenden durchschnittlichen volkswirtschaftlichen Kosten durch Straßenverkehrsunfälle, die bei einer Fahrleistung von 1000 Kfz-km in diesem Straßenabschnitt entstanden sind.” (FGSV (2003), S.5). Die Formel lautet entsprechend:</p>
<p><span class="math display">\[
UKR = \frac{1000 \cdot UK}{365 \cdot DTV \cdot L \cdot t}
\]</span></p>
<p>Die Unfallkosten UK werden über einen Betrachtungszeitraum von drei Jahren berechnet. Je nachdem, welche Unfalldaten vorliegen, werden unterschiedliche Formeln angewandt. Da aus dem Unfallatlas nur Unfälle mit Personenschaden und keine mit Sachschäden zur Verfügung stehen, wird die folgende Formel verwendet:</p>
<p><span class="math display">\[
UK = U(SP) * WU(SP) + U(LV) * WU(LV)
\]</span></p>
<p>mit</p>
<ul>
<li><strong>U(SP)</strong> : Unfälle mit schwerem Personenschaden (Schwerverletzte und Getötete)</li>
<li><strong>WU(SP)</strong> : Unfallkostensatz von Unfällen mit schwerem Personenschaden</li>
<li><strong>U(LV)</strong> : Unfälle mit leichtem Personenschaden</li>
<li><strong>WU(LV)</strong> : Unfallkostensatz von Unfällen mit leichtem Personenschaden</li>
</ul>
<p>Die Unfallkostensätze werden dem Merkblatt zur Örtlichen Unfalluntersuchung in Unfallkommissionen (M Uko) (FGSV, 2012) entnommen.</p>
<section id="schritt-1-unfalldaten" class="level4" data-number="3.2.3.1">
<h4 data-number="3.2.3.1" class="anchored" data-anchor-id="schritt-1-unfalldaten"><span class="header-section-number">3.2.3.1</span> Schritt 1: Unfalldaten</h4>
<p>TO-DO Unfalldaten aus drei Jahren: Z- und M-Dimensionen entfernen</p>
<p>To-DO Nächst gelegene Autobahn und Entfernung zu dieser ergänzen:</p>
<p>To-DO Unfälle nach Abschnitten zusammenfassen</p>
<p>Alle Unfalljahre zusammenführen</p>
<p>Unfallsummen nach Kategorien bilden</p>
<p>Schwere Unfälle: Kategorie 1 + Kategorie 2 Leichte Unfälle: Kategorie 3</p>
<p>Ergebnisse zusammenführen</p>
<p>Unfälle dem Datensatz des Bundesfernstraßennetzes hinzufügen</p>
</section>
<section id="schritt-2-dauerzählstellen" class="level4" data-number="3.2.3.2">
<h4 data-number="3.2.3.2" class="anchored" data-anchor-id="schritt-2-dauerzählstellen"><span class="header-section-number">3.2.3.2</span> Schritt 2: Dauerzählstellen</h4>
<p>TO-DO. mit function arbeiten DTV-Daten aus den gleichen drei Jahren</p>
<p>Nur Zählstellen an Autobahnen mit Zähldaten berücksichtigen. Koordinaten der Zählstelle als simple feature anlegen, da nur so weitere sf-Funktionen verwendet werden können Den Zählstellen Autobahnabschnitten des Bundesfernwegenetzes zuordnen</p>
<p>DTV auf Abschnittsebene zusammenfassen</p>
<p>Alle DTV Jahre zusammenführen</p>
<p>Mittelwerte pro Abschnitt aus den drei Jahren ermitteln</p>
<p>DTV-Daten dem Datensatz des Bundesfernstraßennetzes hinzufügen</p>
</section>
<section id="schritt-3-unfallkostensätze-definieren" class="level4" data-number="3.2.3.3">
<h4 data-number="3.2.3.3" class="anchored" data-anchor-id="schritt-3-unfallkostensätze-definieren"><span class="header-section-number">3.2.3.3</span> Schritt 3: Unfallkostensätze definieren</h4>
</section>
<section id="schritt-4-unfallkostenraten-berechnen" class="level4" data-number="3.2.3.4">
<h4 data-number="3.2.3.4" class="anchored" data-anchor-id="schritt-4-unfallkostenraten-berechnen"><span class="header-section-number">3.2.3.4</span> Schritt 4: Unfallkostenraten berechnen</h4>
</section>
<section id="schritt-5-ausgewählte-autobahn" class="level4" data-number="3.2.3.5">
<h4 data-number="3.2.3.5" class="anchored" data-anchor-id="schritt-5-ausgewählte-autobahn"><span class="header-section-number">3.2.3.5</span> Schritt 5: Ausgewählte Autobahn</h4>
</section>
<section id="schritt-6-grafische-darstellung" class="level4" data-number="3.2.3.6">
<h4 data-number="3.2.3.6" class="anchored" data-anchor-id="schritt-6-grafische-darstellung"><span class="header-section-number">3.2.3.6</span> Schritt 6: Grafische Darstellung</h4>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sicherheitsanalyse_files/figure-html/unnamed-chunk-35-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="unfallkostendichte-ukd" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="unfallkostendichte-ukd"><span class="header-section-number">3.2.4</span> Unfallkostendichte UKD</h3>
<p>Die Unfallkostendichte UKD beschreibt “die mittleren volkswirtschaftlichen Kosten durch Straßenverkehrsunfälle, die auf 1 km Länge des Straßenabschnittes entfallen” (FGSV (2003), S. 6).</p>
<p>Die Formel lautet:</p>
<p><span class="math display">\[
UKD = \frac{UK}{1000 \cdot L \cdot t}
\]</span></p>
<p>Da die Unfallkosten bereits berechnet sind, ist die Berechnung der Unfallkostendichte nun schneller.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sicherheitsanalyse_files/figure-html/unnamed-chunk-38-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="sicherheitspotenzial-sipo" class="level3" data-number="3.2.5">
<h3 data-number="3.2.5" class="anchored" data-anchor-id="sicherheitspotenzial-sipo"><span class="header-section-number">3.2.5</span> Sicherheitspotenzial SIPO</h3>
<p>“Das Sicherheitspotenzial SIPO eines Straßenabschnittes ist definiert als Unterschied zwischen den Unfallkosten (Anzahl und Schwere der Unfälle), die bei richtliniengerechtem Ausbau zu erwarten wären, und den vorhandenen Unfallkosten. […] Kenngröße für das Sicherheitspotenzial SIPO ist die Differenz zwischen der vorhandenen Unfallkostendichte UKD eines Netzabschnittes im Betrachtungszeitraum und der Grundunfallkostendichte gUKD.” (FGSV (2003), S. 8f.)</p>
<p><span class="math display">\[
SIPO = UKD - gUKD
\]</span></p>
<p>Die Grundunfallkostendichte gUKD wird mit der folgenden Formel berechnet:</p>
<p><span class="math display">\[
gUKD = \frac{gUKR \cdot DTV \cdot 365}{10^6}
\]</span></p>
<p>mit der Grundunfallkostenrate gUKR, die den ESN zu entnehmen ist.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="sicherheitsanalyse_files/figure-html/unnamed-chunk-42-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>To-DO BEschriftung</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopiert");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopiert");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./musterloesung.html" class="pagination-link" aria-label="Musterlösung Sicherheitsanalyse">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Musterlösung Sicherheitsanalyse</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/bausteine-der-datenanalyse/a-sicherheitsanalyse/blob/main/sicherheitsanalyse.qmd" class="toc-action"><i class="bi bi-github"></i>Quellcode anzeigen</a></li></ul></div></div></div></footer></body></html>